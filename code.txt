================================================================================
FILE: app/layout.tsx
================================================================================

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Creative Management System",
  description: "A comprehensive system for managing creative assets and campaigns",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}

================================================================================
FILE: app/page.tsx
================================================================================

import CreativeForm from "@/Form/CreativeForm";

export default function Home() {
  return (
    <main className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
      <div className="mx-auto max-w-4xl">
        <div className="mb-8 text-center">
          <h1 className="mb-4 text-4xl font-bold text-gray-900">
            Creative Management System
          </h1>
          <p className="text-lg text-gray-600">
            Upload and manage your creative assets with ease
          </p>
        </div>
        <CreativeForm />
      </div>
    </main>
  );
}

================================================================================
FILE: app/globals.css
================================================================================

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96%;
    --secondary-foreground: 222.2 84% 4.9%;
    --muted: 210 40% 96%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96%;
    --accent-foreground: 222.2 84% 4.9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 84% 4.9%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 94.1%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================================================================================
FILE: app/thankyou/[submissionId]/page.tsx
================================================================================

  import { notFound } from "next/navigation";

  interface ThankYouPageProps {
    params: { submissionId: string };
    searchParams: { 
      type?: string; 
      count?: string; 
      trackingLink?: string;
    };
  }

  export default function ThankYou({ params, searchParams }: ThankYouPageProps) {
    const { submissionId } = params;
    
    if (!submissionId || submissionId === "unknown") {
      return notFound();
    }

    const { type, count, trackingLink } = searchParams;

    return (
      <div className="min-h-screen bg-gradient-to-br from-green-50 to-emerald-100 flex items-center justify-center p-4">
        <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-8 text-center">
          <div className="mb-6">
            <div className="mx-auto w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mb-4">
              <svg className="w-8 h-8 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
              </svg>
            </div>
            <h1 className="text-2xl font-bold text-gray-900 mb-2">Thank You!</h1>
            <p className="text-gray-600 mb-2">
              Your creative has been successfully submitted.
            </p>
            <div className="text-sm text-gray-500 space-y-1">
              <p>Submission ID: <span className="font-mono font-semibold">{submissionId}</span></p>
              {type && (
                <p>Type: <span className="font-mono">{type}</span></p>
              )}
              {count && (
                <p>Files: <span className="font-mono">{count}</span></p>
              )}
            </div>
            {trackingLink && (
              <div className="mt-4 p-3 bg-blue-50 rounded-lg">
                <p className="text-sm text-blue-800 mb-2">Track your submission:</p>
                <a 
                  className="text-blue-600 underline break-all text-sm hover:text-blue-800" 
                  href={trackingLink} 
                  target="_blank" 
                  rel="noreferrer"
                >
                  {trackingLink}
                </a>
              </div>
            )}
          </div>
          
          <div className="space-y-3">
            <a
              href="/"
              className="block w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition-colors"
            >
              Submit Another Creative
            </a>
            
            <a
              href="/"
              className="block w-full bg-gray-100 text-gray-700 py-2 px-4 rounded-md hover:bg-gray-200 transition-colors"
            >
              Back to Home
            </a>
          </div>
        </div>
      </div>
    );
  }

================================================================================
FILE: app/thankyou/[submissionId]/layout.tsx
================================================================================

  export default function ThankYouLayout({
    children,
  }: {
    children: React.ReactNode;
  }) {
    return <>{children}</>;
  }

================================================================================
FILE: app/thankyou/layout.tsx
================================================================================

export default function ThankYouLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <>{children}</>;
}

================================================================================
FILE: app/thankyou/page.tsx
================================================================================

import Link from "next/link";

export default function ThankYou() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-green-50 to-emerald-100 flex items-center justify-center p-4">
      <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-8 text-center">
        <div className="mb-6">
          <div className="mx-auto w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mb-4">
            <svg className="w-8 h-8 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
            </svg>
          </div>
          <h1 className="text-2xl font-bold text-gray-900 mb-2">Thank You!</h1>
          <p className="text-gray-600">
            Your creative has been successfully submitted. We'll review it and get back to you soon.
          </p>
        </div>
        
        <div className="space-y-3">
          <Link
            href="/"
            className="block w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition-colors"
          >
            Submit Another Creative
          </Link>
          
          <Link
            href="/"
            className="block w-full bg-gray-100 text-gray-700 py-2 px-4 rounded-md hover:bg-gray-200 transition-colors"
          >
            Back to Home
          </Link>
        </div>
      </div>
    </div>
  );
}

================================================================================
FILE: constants/apiEndpoints.ts
================================================================================

  // API Endpoints Configuration
  // This file centralizes all API endpoint definitions to ensure consistency
  // between frontend and backend implementations

export const API_ENDPOINTS = {
    // File Upload & Management
  UPLOAD: '/api/upload',
  UPLOAD_ZIP: '/api/upload-zip',
  UPLOAD_URL: '/api/upload-url',
    UPLOAD_PROGRESS: '/api/upload-progress',
  ANALYZE_ZIP: '/api/analyze-zip',
  GET_FILE_CONTENT: '/api/get-file-content',
    
    // File Operations
    FILES: '/api/files',
    FILES_BULK_DELETE: '/api/files/bulk-delete',
    
    // Creative Management
  CREATIVE_SAVE: '/api/creative/save',
  CREATIVE_SAVE_HTML: '/api/creative/save-html',
  CREATIVE_SAVE_METADATA: '/api/creative/save-metadata',
  CREATIVE_GET_METADATA: '/api/creative/get-metadata',
  CREATIVE_RENAME: '/api/creative/rename',
  CREATIVE_DELETE: '/api/creative/delete',
    
    // Content Generation & Proofreading
    GENERATE_EMAIL_CONTENT: '/api/generate-email-content',
    PROOFREAD: '/api/proofread',
    PROOFREAD_CREATIVE: '/api/proofread-creative',
    PROOFREAD_IMAGE: '/api/proofread-image',
    PROOFREAD_TEXT: '/api/proofread-text',
    
    // External Integrations
    EVERFLOW_OFFERS: '/api/everflow/offers',
    
    // Telegram Integration
    TELEGRAM_VERIFY: '/api/telegram/verify',
    TELEGRAM_POLL: '/api/telegram/poll',
    TELEGRAM_WEBHOOK: '/api/telegram-webhook', // Note: This is a separate endpoint, not in /telegram/ folder
    CHECK_TELEGRAM_START: '/api/check-telegram-start',
    
    // Submissions & Tracking
    SUBMISSIONS: '/api/submissions',
    
    // ZIP Preview (Optional - for advanced ZIP preview functionality)
    ZIP_PREVIEW: '/api/zip/preview'
  } as const;

  // File serving endpoint patterns
  // The backend supports multiple file serving patterns for flexibility:
  export const FILE_SERVING_PATTERNS = {
    // Single file by ID
    BY_ID: '/api/files/[id]',
    // File by ID and name
    BY_ID_AND_NAME: '/api/files/[id]/[name]', 
    // Dynamic path serving (most flexible)
    DYNAMIC_PATH: '/api/files/[...path]'
  } as const;

  // Request/Response type definitions for better type safety
  export type ApiEndpoint = typeof API_ENDPOINTS[keyof typeof API_ENDPOINTS];

  // Helper function to get endpoint URL
  export const getApiEndpoint = (endpoint: keyof typeof API_ENDPOINTS): string => {
    return API_ENDPOINTS[endpoint];
  };

  // Helper function to build file serving URLs
  export const buildFileUrl = (id: string, path?: string): string => {
    if (path) {
      return `/api/files/${encodeURIComponent(id)}/${encodeURIComponent(path)}`;
    }
    return `/api/files/${encodeURIComponent(id)}`;
  };

  // Helper function to build upload progress URL
  export const buildUploadProgressUrl = (uploadId: string): string => {
    return `${API_ENDPOINTS.UPLOAD_PROGRESS}?id=${encodeURIComponent(uploadId)}`;
  };

================================================================================
FILE: constants/index.ts
================================================================================

  // Export all constants
  export * from './fileUpload'
  export * from './apiEndpoints'

  // Telegram Bot Configuration
  export const TELEGRAM_BOT_URL = 'https://t.me/BigDropsMarketingBot?start=from_web_form'

================================================================================
FILE: hooks/useUploadProgress.ts
================================================================================

  import { useState, useEffect, useCallback } from 'react';
  import { buildUploadProgressUrl } from '@/constants/apiEndpoints';

  interface UploadProgressState {
    status: 'idle' | 'uploading' | 'processing' | 'completed' | 'failed';
    percentage: number;
    message: string;
    error?: string;
  }

  interface UseUploadProgressOptions {
    uploadId?: string;
    pollInterval?: number;
    onComplete?: () => void;
    onError?: (error: string) => void;
  }

  export const useUploadProgress = (options: UseUploadProgressOptions = {}) => {
    const { uploadId, pollInterval = 1000, onComplete, onError } = options;
    
    const [progress, setProgress] = useState<UploadProgressState>({
      status: 'idle',
      percentage: 0,
      message: 'Ready to upload'
    });

    const [isPolling, setIsPolling] = useState(false);

    const startPolling = useCallback(() => {
      if (!uploadId || isPolling) return;
      
      setIsPolling(true);
      setProgress(prev => ({ ...prev, status: 'uploading', message: 'Uploading...' }));
    }, [uploadId, isPolling]);

    const stopPolling = useCallback(() => {
      setIsPolling(false);
    }, []);

    const resetProgress = useCallback(() => {
      setProgress({
        status: 'idle',
        percentage: 0,
        message: 'Ready to upload'
      });
      setIsPolling(false);
    }, []);

    // Poll for upload progress
    useEffect(() => {
      if (!isPolling || !uploadId) return;

      const pollProgress = async () => {
        try {
          const response = await fetch(buildUploadProgressUrl(uploadId));
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const data = await response.json();
          
          setProgress({
            status: data.status || 'uploading',
            percentage: data.pct || 0,
            message: data.message || 'Processing...'
          });

          // Check if upload is complete
          if (data.status === 'completed' || data.status === 'failed') {
            setIsPolling(false);
            
            if (data.status === 'completed') {
              onComplete?.();
            } else if (data.status === 'failed') {
              onError?.(data.error || 'Upload failed');
            }
          }
        } catch (error) {
          console.error('Failed to fetch upload progress:', error);
          setProgress(prev => ({
            ...prev,
            status: 'failed',
            error: error instanceof Error ? error.message : 'Unknown error'
          }));
          setIsPolling(false);
          onError?.(error instanceof Error ? error.message : 'Unknown error');
        }
      };

      const interval = setInterval(pollProgress, pollInterval);
      return () => clearInterval(interval);
    }, [isPolling, uploadId, pollInterval, onComplete, onError]);

    return {
      progress,
      isPolling,
      startPolling,
      stopPolling,
      resetProgress
    };
  };

================================================================================
FILE: app/Constants/Constants.ts
================================================================================

  export const Constants = {
      logo: "/Logo.svg",
      background: "/Background.svg",

      // Form Constants
      formTitle: "Submit Your Creatives For Approval",
      formDescription: "Upload your static images or HTML creatives with offer details to begin the approval process. Our team will review and notify you shortly.",

      // Form Fields
      formFields: [
          {
              label: "Affiliate ID",
              name: "affiliateId",
              type: "text",
              placeholder: "Enter Affiliate ID",
          },
          {
              label: "Company Name",
              name: "companyName",
              type: "text",
              placeholder: "Enter Company Name",
          },
          {
              label: "First Name",
              name: "firstName",
              type: "text",
              placeholder: "Enter First Name",
          },
          {
              label: "Last Name",
              name: "lastName",
              type: "text",
              placeholder: "Enter Last Name",
          },
          {
              label: "Email",
              name: "email",
              type: "email",
              placeholder: "Enter Email",
          },
          {
              label: "Telegram ID (Optional)",
              name: "telegramId",
              type: "text",
              placeholder: "Enter Telegram ID",
          },
          {
              label: "Offer ID",
              name: "offerId",
              type: "select",
              options: [
                  { label: "Loading offers...", value: "loading" },
              ],
              placeholder: "Select Offer",
          },
          {
              label: "Creative Type",
              name: "creativeType",
              type: "select",
              options: [
                  { label: "Email", value: "email" },
                  { label: "Display", value: "display" },
                  { label: "Search", value: "search" },
                  { label: "Social", value: "social" },
                  { label: "Native", value: "native" },
                  { label: "Push", value: "push" },
              ],
              placeholder: "Select Creative Type",
          },
          {
              label: "Additional Notes or Requests for Client",
              name: "additionalNotes",
              type: "textarea",
              placeholder: "Enter Additional Notes or Requests for Client",
          },
          {
              label: "From Lines",
              name: "fromLines",
              type: "textarea",
              placeholder: "Enter From Lines",
          },
          {
              label: "Subject Lines",
              name: "subjectLines",
              type: "textarea",
              placeholder: "Enter Subject Lines",
          },
      ],

      // Upload Creative Types
      uploadCreativeTypes: [ 
          { label: "Single Creative", value: "singleCreative" },
          { label: "Multiple Creatives", value: "multipleCreatives" },
          { label: "From & Subject Lines", value: "fromSubjectLines" },
      ],

      // Button Texts
      buttonTexts: {
          next: "Next",
          previous: "Previous",
          submit: "Submit Creative",
          loading: "Loading...",
          verifying: "Verifying...",
          verify: "Verify",
          verified: "Verified",
          startBot: "Start Bot",
          nextStep2: "Save & Add Contact Details",
          prevStep1: "Edit Personal Details",
          nextStep3: "Save & Add Creative Details",
          prevStep2: "Edit Contact Details",
      },

      // Step Labels
      stepLabels: {
          step1: "Personal Details",
          step2: "Contact Details", 
          step3: "Creative Details",
      },

      // Current Step
      currentStep: [
          {
              stepNumber: 1,
              stepLabel: "Personal Details",
          },
          {
              stepNumber: 2,
              stepLabel: "Contact Details",
          },
          {
              stepNumber: 3,
              stepLabel: "Creative Details",
          },
      ],
      
      totalSteps: 3,

      // Verification Steps
      verificationSteps: [
          "Click on Start Bot Button",
          "Send /start to the bot",
          "Come back and Verify again",
      ],

      // From & Subject Lines Configuration
      fromSubjectLinesConfig: {
          title: "From & Subject Lines",
          description: "Enter compelling from lines and subject lines for your email campaigns",
          guidelines: {
              title: "Email Content Guidelines:",
              items: [
                  "From Lines: Enter the sender name/email that will appear in the \"From\" field",
                  "Subject Lines: Enter compelling subject lines to improve email open rates",
                  "Multiple Lines: You can enter multiple options separated by line breaks",
                  "Best Practices: Keep subject lines under 50 characters for better display"
              ]
          },
          fromLines: {
              label: "From Lines *",
              placeholder: "Enter from lines",
              helpText: "Enter multiple from lines separated by line breaks. Each line will be used as an option.",
              required: true
          },
          subjectLines: {
              label: "Subject Lines *",
              placeholder: "Enter subject lines",
              helpText: "Enter multiple subject lines separated by line breaks. Each line will be used as an option.",
              required: true
          },
          buttons: {
              save: "Save Lines",
              cancel: "Cancel"
          },
          characterCount: {
              fromLines: "From Lines: {count} characters",
              subjectLines: "Subject Lines: {count} characters"
          }
      },

      // Priority
      priorityLevels: [
          { name: "High", value: "High" },
          { name: "Medium", value: "Medium" },
      ],

      // ZIP Processing Constants
      zipProcessing: {
          MAX_ZIP_SIZE: 150 * 1024 * 1024, // 150MB
          LARGE_ZIP_WARNING_THRESHOLD: 100 * 1024 * 1024, // 100MB - warn but allow
          MAX_FILES_PER_ZIP: 100,
          MAX_ZIP_DEPTH: 5,
          ALLOWED_ZIP_TYPES: [
              'application/zip',
              'application/x-zip-compressed',
              'application/octet-stream'
          ],
          ALLOWED_EXTENSIONS: [
              '.html', '.htm', '.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg',
              '.css', '.js', '.txt', '.pdf', '.doc', '.docx'
          ],
  SCAN_VIRUSES: true,
          VALIDATE_FILE_TYPES: true,
          CHECK_FILE_HEADERS: true,
          // HTML entry file preferences
          HTML_ENTRY_PREFERENCES: ['index.html', 'index.htm', 'main.html', 'home.html'],
          // Image file extensions
          IMAGE_EXTENSIONS: ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg'],
          // HTML file extensions  
          HTML_EXTENSIONS: ['.html', '.htm']
      }
  }

================================================================================
FILE: components/ui/button.tsx
================================================================================

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================================================================================
FILE: components/ui/card.tsx
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================================================================================
FILE: components/ui/input.tsx
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================================================================================
FILE: components/ui/label.tsx
================================================================================

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

================================================================================
FILE: components/ui/progress.tsx
================================================================================

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-md bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

================================================================================
FILE: components/ui/select.tsx
================================================================================

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================================================================================
FILE: components/ui/textarea.tsx
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }

================================================================================
FILE: components/ui/validation-summary.tsx
================================================================================

interface ValidationSummaryProps {
  errors: Record<string, string>;
}

export function ValidationSummary({ errors }: ValidationSummaryProps) {
  const errorEntries = Object.entries(errors).filter(([_, message]) => message);
  
  if (errorEntries.length === 0) return null;

  return (
    <div className="rounded-md bg-red-50 p-4 border border-red-200">
      <div className="flex">
        <div className="flex-shrink-0">
          <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
          </svg>
        </div>
        <div className="ml-3">
          <h3 className="text-sm font-medium text-red-800">
            Please fix the following errors:
          </h3>
          <div className="mt-2 text-sm text-red-700">
            <ul className="list-disc pl-5 space-y-1">
              {errorEntries.map(([field, message]) => (
                <li key={field}>
                  <span className="font-medium capitalize">{field.replace(/([A-Z])/g, ' $1').trim()}:</span> {message}
                </li>
              ))}
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
}

================================================================================
FILE: app/Form/CreativeForm.tsx
================================================================================

"use client";

  import React, { useState, useMemo, useCallback } from "react";
  import { Constants } from "@/app/Constants/Constants";
  import { API_ENDPOINTS } from "@/constants/apiEndpoints";
  import Image from "next/image";
  import {
    Card,
    CardContent,
    CardDescription,
    CardFooter,
    CardHeader,
    CardTitle,
  } from "@/components/ui/card";
  import { Separator } from "@/components/ui/separator";
import { Button } from "@/components/ui/button";
  import { ValidationSummary } from "@/components/ui/validation-summary";
  import PersonalDetails from "@/app/Form/Steps/PersonalDetails";
  import ContactDetails from "@/app/Form/Steps/ContactDetails";
  import CreativeDetails from "@/app/Form/Steps/CreativeDetails";
  import { useFormValidation } from "@/hooks/useFormValidation";

  type FileMeta = {
    id: string;
    name: string;
    url: string;
    size: number;
    type: string;
    source?: "single" | "zip";
    html?: boolean;
  };

  const CreativeForm = () => {
  const [currentStep, setCurrentStep] = useState(1);

    const [files, setFiles] = useState<FileMeta[]>([]);

    const initialFormData = {
      affiliateId: "",
      companyName: "",
    firstName: "",
    lastName: "",

      // Contact Details
    email: "",
    telegramId: "",

      // Creative Details
      offerId: "",
      creativeType: "",
    additionalNotes: "",
      fromLines: "",
      subjectLines: "",
      priority: "Medium",

      // Files (will be populated by upload handlers)
      uploadedFiles: [] as Array<{
        fileId: string;
        fileName: string;
        fileUrl: string;
        fileSize: number;
        fileType: string;
      }>,
    };

    const [formData, setFormData] = useState(initialFormData);

    const [isSubmitting, setIsSubmitting] = useState(false);

    // Initialize validation hook
    const validationHook = useFormValidation(initialFormData);

  const handleNext = () => {
      if (currentStep < Constants.totalSteps) {
        // Validate current step before proceeding
        let isStepValid = false;

        switch (currentStep) {
          case 1:
            const personalValidation =
              validationHook.validatePersonalDetailsStep(formData);
            isStepValid = personalValidation.isValid;
            break;
          case 2:
            const contactValidation =
              validationHook.validateContactDetailsStep(formData);
            isStepValid = contactValidation.isValid;
            break;
          case 3:
            const creativeValidation = validationHook.validateCreativeDetailsStep(
              formData,
              files.length > 0,
              false
            );
            isStepValid = creativeValidation.isValid;
            break;
          default:
            isStepValid = true;
        }

        if (isStepValid) {
          setCurrentStep(currentStep + 1);
          // Clear errors when moving to next step
          validationHook.clearErrors();
        } else {
          // Mark all fields in current step as touched to show errors
          if (currentStep === 1) {
            ["affiliateId", "companyName", "firstName", "lastName"].forEach(
              (field) => {
                validationHook.markFieldAsTouched(field);
              }
            );
          } else if (currentStep === 2) {
            ["email"].forEach((field) => {
              validationHook.markFieldAsTouched(field);
            });
            if (formData.telegramId && formData.telegramId !== "@") {
              validationHook.markFieldAsTouched("telegramId");
            }
          } else if (currentStep === 3) {
            ["offerId", "creativeType", "priority"].forEach((field) => {
              validationHook.markFieldAsTouched(field);
            });
          }
        }
      }
    };

    const handleFormDataChange = (stepData: Partial<typeof formData>) => {
      setFormData((prev) => {
        const newData = { ...prev, ...stepData };
        return newData;
      });
  };

  const handleSubmit = async () => {
      if (currentStep !== Constants.totalSteps) return;

      // Validate complete form before submission
      const completeValidation = validationHook.validateCompleteFormData(
        formData,
        files.length > 0,
        false
      );
      if (!completeValidation.isValid) {
        // Mark all fields as touched to show errors
        Object.keys(completeValidation.errors).forEach((field) => {
          validationHook.markFieldAsTouched(field);
        });
        return;
      }

      setIsSubmitting(true);
      try {
        // Current implementation - Replace with backend logic:
        const response = await fetch(API_ENDPOINTS.CREATIVE_SAVE, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            affiliateId: formData.affiliateId,
            companyName: formData.companyName,
            firstName: formData.firstName,
            lastName: formData.lastName,
            email: formData.email,
            telegramId: formData.telegramId,
            offerId: formData.offerId,
            creativeType: formData.creativeType,
            fromLines: formData.fromLines,
            subjectLines: formData.subjectLines,
            notes: formData.additionalNotes,
            priority: formData.priority,
            files: files.map((f) => ({
              fileName: f.name,
              fileUrl: f.url,
              fileType: f.type,
              fileSize: f.size,
            })),
          }),
        });

        if (response.ok) {
          const result = await response.json();
          console.log("Creative saved successfully:", result);

          // Implement redirection logic
          const submissionType = files.length > 1 ? "multiple" : "single";
          const fileCount = files.length;

          // Store submission data in localStorage as fallback
          localStorage.setItem("creativeSubmissionType", submissionType);
          localStorage.setItem("creativeFileCount", fileCount.toString());
          localStorage.setItem("submissionId", result.submissionId || "");
          localStorage.setItem("trackingLink", result.trackingLink || "");

          // Redirect to /thankyou with submission ID as slug
          const submissionId = result.submissionId || "unknown";
          window.location.href = `/thankyou/${submissionId}?type=${submissionType}&count=${fileCount}&trackingLink=${encodeURIComponent(
            result.trackingLink || ""
          )}`;
        } else {
          throw new Error("Failed to save creative");
        }
    } catch (error) {
        console.error("Submission failed:", error);
      } finally {
        setIsSubmitting(false);
      }
    };

    const handlePrev = () => {
      if (currentStep > 1) {
        setCurrentStep(currentStep - 1);
        // Clear errors when going back
        validationHook.clearErrors();
      }
    };

    const getStepContent = () => {
    switch (currentStep) {
      case 1:
          return (
            <PersonalDetails
              formData={formData}
              onDataChange={handleFormDataChange}
              validationHook={validationHook}
            />
          );
      case 2:
          return (
            <ContactDetails
              formData={formData}
              onDataChange={handleFormDataChange}
              validationHook={validationHook}
            />
          );
        case 3:
          return (
            <CreativeDetails
              formData={formData}
              onDataChange={handleFormDataChange}
              onFilesChange={setFiles}
              validationHook={validationHook}
            />
          );
        default:
          return <div>Step not found</div>;
      }
    };

    const getStepLabel = () => {
      return (
        Constants.currentStep.find((step) => step.stepNumber === currentStep)
          ?.stepLabel || ""
      );
    };

    const getButtonText = () => {
      if (currentStep === 1) {
        return { prev: "Back", next: Constants.buttonTexts.nextStep2 };
      } else if (currentStep === 2) {
        return { 
          prev: Constants.buttonTexts.prevStep1,
          next: Constants.buttonTexts.nextStep3,
        };
      } else {
        return {
          prev: Constants.buttonTexts.prevStep2,
          next: Constants.buttonTexts.submit,
        };
      }
    };

    // Check if current step is valid for enabling next button
    const isCurrentStepValid = useCallback(() => {
      // Check if required fields have values for the current step
      switch (currentStep) {
        case 1:
          return Boolean(
            formData.affiliateId?.trim() &&
              formData.companyName?.trim() &&
              formData.firstName?.trim() &&
              formData.lastName?.trim()
          );
        case 2:
          return Boolean(formData.email?.trim());
        case 3:
          return Boolean(
            formData.offerId?.trim() &&
              formData.creativeType?.trim() &&
              formData.priority?.trim()
          );
        default:
          return true;
      }
    }, [currentStep, formData]);

  return (
      <div
        className="flex flex-col items-center min-h-screen py-8 px-4"
        style={{
          backgroundImage: `url(${Constants.background})`,
          backgroundColor: "var(--color-primary-50)",
          backgroundRepeat: "no-repeat",
          backgroundPosition: "center",
          backgroundSize: "cover",
        }}
      >
        <div className="flex flex-col items-center justify-center mb-8">
          <Image
            src={Constants.logo}
            alt="logo"
            width={100}
            height={100}
            className="w-40 md:w-60 h-10 md:h-20"
          />
      </div>

        <Card className="w-full max-w-3xl mx-auto shadow-xl">
          <CardHeader>
            <CardTitle className="text-2xl sm:text-4xl font-bold text-heading">
              {Constants.formTitle}
            </CardTitle>
            <CardDescription className="text-base sm:text-lg text-body leading-relaxed py-4">
              {Constants.formDescription}
            </CardDescription>
            <div>
              <p className="text-base sm:text-lg font-semibold text-primary-500">
                Step {currentStep} of {Constants.totalSteps} : {getStepLabel()}
              </p>
            </div>
            <Separator className="mt-4" />
          </CardHeader>
          <CardContent>{getStepContent()}</CardContent>
          <CardFooter>
            <div className="flex flex-col justify-between gap-4 w-full">
              {currentStep > 1 && (
                <Button variant="outline" className="w-full" onClick={handlePrev}>
                  {getButtonText().prev}
                </Button>
              )}
          <Button
                className="w-full"
                onClick={
                  currentStep === Constants.totalSteps ? handleSubmit : handleNext
                }
                disabled={
                  isSubmitting ||
                  (currentStep < Constants.totalSteps && !isCurrentStepValid())
                }
              >
                {isSubmitting ? "Submitting..." : getButtonText().next}
          </Button>
        </div>
          </CardFooter>
      </Card>
    </div>
  );
  };

  export default CreativeForm;

================================================================================
FILE: types/upload.ts
================================================================================

export interface UploadRequest {
  file?: File;
  zip?: File;
  url?: string;
  metadata?: UploadMetadata;
}

export interface UploadMetadata {
  title?: string;
  description?: string;
  tags?: string[];
  category?: string;
  creativeType?: 'single' | 'multiple';
  targetAudience?: string;
  campaignGoals?: string;
  budget?: string;
  timeline?: string;
  additionalNotes?: string;
}

export interface UploadResponse {
  success: boolean;
  filename?: string;
  files?: string[];
  message: string;
  error?: string;
  metadata?: {
    fileSize: number;
    fileType: string;
    uploadDate: string;
    checksum: string;
  };
}

export interface UploadProgress {
  filename: string;
  progress: number;
  status: 'pending' | 'uploading' | 'processing' | 'completed' | 'failed';
  message?: string;
}

export interface FileInfo {
  id: string;
  filename: string;
  originalName: string;
  fileSize: number;
  fileType: string;
  uploadDate: string;
  checksum: string;
  status: string;
  metadata?: UploadMetadata;
}

================================================================================
FILE: types/proofread.ts
================================================================================

export interface ProofreadRequest {
  content: string;
  type: 'text' | 'creative' | 'image';
  language?: string;
  tone?: 'formal' | 'casual' | 'professional' | 'friendly';
  targetAudience?: string;
  industry?: string;
}

export interface ProofreadResponse {
  success: boolean;
  originalContent: string;
  correctedContent: string;
  suggestions: ProofreadSuggestion[];
  summary: {
    totalIssues: number;
    criticalIssues: number;
    minorIssues: number;
    readabilityScore?: number;
  };
  metadata: {
    processingTime: number;
    model: string;
    timestamp: string;
  };
}

export interface ProofreadSuggestion {
  type: 'spelling' | 'grammar' | 'style' | 'clarity' | 'tone';
  severity: 'critical' | 'minor' | 'suggestion';
  original: string;
  suggestion: string;
  explanation: string;
  position: {
    start: number;
    end: number;
    line?: number;
  };
}

export interface ImageProofreadRequest {
  imageUrl: string;
  imageData?: string; // base64 encoded
  analysisType: 'text' | 'content' | 'branding' | 'accessibility';
  context?: string;
}

export interface ImageProofreadResponse {
  success: boolean;
  imageUrl: string;
  analysis: {
    textContent?: string;
    contentDescription?: string;
    brandingElements?: string[];
    accessibilityIssues?: string[];
    suggestions: string[];
  };
  metadata: {
    processingTime: number;
    model: string;
    timestamp: string;
  };
}

================================================================================
FILE: lib/utils.ts
================================================================================

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================================================================================
FILE: hooks/useFormValidation.ts
================================================================================

  import { useState, useCallback } from 'react'
  import { 
    validatePersonalDetails, 
    validateContactDetails, 
    validateCreativeDetails,
    validateCompleteForm,
    FormValidationResult,
    getFieldError
  } from '@/utils/validations'

  export interface FormData {
    affiliateId: string
    companyName: string
    firstName: string
    lastName: string
    email: string
    telegramId: string
    offerId: string
    creativeType: string
    additionalNotes: string
    fromLines: string
    subjectLines: string
    priority: string
  }

  export interface ValidationState {
    errors: Record<string, string>
    touched: Record<string, boolean>
    isValid: boolean
  }

  export const useFormValidation = (initialFormData: FormData) => {
    const [validationState, setValidationState] = useState<ValidationState>({
      errors: {},
      touched: {},
      isValid: false
    })
    const [hasUploadedFiles, setHasUploadedFiles] = useState(false)
    const [hasFromSubjectLines, setHasFromSubjectLines] = useState(false)

    // Update form data - this should not trigger state updates that cause infinite loops
    const updateFormData = useCallback((updates: Partial<FormData>) => {
      // This function is now just a placeholder - actual form data is managed by the parent component
      // We don't need to store form data here since it's passed as a parameter to validation functions
    }, [])

    // Mark field as touched
    const markFieldAsTouched = useCallback((fieldName: string) => {
      setValidationState(prev => ({
        ...prev,
        touched: { ...prev.touched, [fieldName]: true }
      }))
    }, [])

    // Mark field as touched on blur
    const handleFieldBlur = useCallback((fieldName: string) => {
      markFieldAsTouched(fieldName)
    }, [markFieldAsTouched])

    // Validate a single field
    const validateField = useCallback((fieldName: string, value: string, isRequired: boolean = true) => {
      const error = getFieldError(fieldName, value, isRequired)
      return error
    }, [])

    // Validate field on change
    const handleFieldChange = useCallback((fieldName: string, value: string, isRequired: boolean = true) => {
      const error = validateField(fieldName, value, isRequired)
      
      setValidationState(prev => ({
        ...prev,
        errors: {
          ...prev.errors,
          [fieldName]: error
        }
      }))
    }, [validateField])

    // Validate personal details step
    const validatePersonalDetailsStep = useCallback((formData: FormData): FormValidationResult => {
      const result = validatePersonalDetails({
        affiliateId: formData.affiliateId,
        companyName: formData.companyName,
        firstName: formData.firstName,
        lastName: formData.lastName
      })
      
      setValidationState(prev => ({
        ...prev,
        errors: { ...prev.errors, ...result.errors }
      }))
      
      return result
    }, [])

    // Validate contact details step
    const validateContactDetailsStep = useCallback((formData: FormData): FormValidationResult => {
      const result = validateContactDetails({
        email: formData.email,
        telegramId: formData.telegramId
      })
      
      setValidationState(prev => ({
        ...prev,
        errors: { ...prev.errors, ...result.errors }
      }))
      
      return result
    }, [])

    // Validate creative details step
    const validateCreativeDetailsStep = useCallback((formData: FormData, hasFiles: boolean, hasLines: boolean): FormValidationResult => {
      const result = validateCreativeDetails(formData, hasFiles, hasLines)
      
      setValidationState(prev => ({
        ...prev,
        errors: { ...prev.errors, ...result.errors }
      }))
      
      return result
    }, [])

    // Validate complete form
    const validateCompleteFormData = useCallback((formData: FormData, hasFiles: boolean, hasLines: boolean): FormValidationResult => {
      const result = validateCompleteForm(formData, hasFiles, hasLines)
      
      setValidationState(prev => ({
        ...prev,
        errors: result.errors,
        isValid: result.isValid
      }))
      
      return result
    }, [])

    // Clear all errors
    const clearErrors = useCallback(() => {
      setValidationState(prev => ({
        ...prev,
        errors: {},
        isValid: false
      }))
    }, [])

    // Clear specific field error
    const clearFieldError = useCallback((fieldName: string) => {
      setValidationState(prev => ({
        ...prev,
        errors: {
          ...prev.errors,
          [fieldName]: ''
        }
      }))
    }, [])

    // Check if a specific field has an error
    const hasFieldError = useCallback((fieldName: string): boolean => {
      return !!validationState.errors[fieldName]
    }, [validationState.errors])

    // Get error message for a specific field
    const getFieldErrorMessage = useCallback((fieldName: string): string => {
      return validationState.errors[fieldName] || ''
    }, [validationState.errors])

    // Check if a field has been touched
    const isFieldTouched = useCallback((fieldName: string): boolean => {
      return !!validationState.touched[fieldName]
    }, [validationState.touched])

    // Check if form is valid
    const isFormValid = useCallback((): boolean => {
      return validationState.isValid
    }, [validationState.isValid])

    // Update file upload state
    const updateFileUploadState = useCallback((hasFiles: boolean) => {
      setHasUploadedFiles(hasFiles)
    }, [])

    // Update from/subject lines state
    const updateFromSubjectLinesState = useCallback((hasLines: boolean) => {
      setHasFromSubjectLines(hasLines)
    }, [])

    // Validate all fields and update validation state
    const validateAllFields = useCallback((formData: FormData, hasFiles: boolean, hasLines: boolean) => {
      const result = validateCompleteFormData(formData, hasFiles, hasLines)
      return result
    }, [validateCompleteFormData])

    // Reset form to initial state
    const resetForm = useCallback(() => {
      setValidationState({
        errors: {},
        touched: {},
        isValid: false
      })
      setHasUploadedFiles(false)
      setHasFromSubjectLines(false)
    }, [])

    // Additional methods expected by components
    const hasErrors = Object.keys(validationState.errors).some(key => validationState.errors[key])
    
    // Validate form method (used by some components)
    const validateForm = useCallback((data: Record<string, string>) => {
      const result = validateCompleteFormData(data as FormData, hasUploadedFiles, hasFromSubjectLines)
      return result.isValid
    }, [validateCompleteFormData, hasUploadedFiles, hasFromSubjectLines])

    return {
      // Core validation state
      errors: validationState.errors,
      hasErrors,
      isValid: validationState.isValid,
      
      // Core methods
      validateField,
      validateForm,
      clearErrors,
      
      // Methods used by step components
      handleFieldChange,
      handleFieldBlur,
      getFieldErrorMessage,
      hasFieldError,
      isFieldTouched,
      markFieldAsTouched,
      
      // Step validation methods used by CreativeForm
      validatePersonalDetailsStep,
      validateContactDetailsStep,
      validateCreativeDetailsStep,
      validateCompleteFormData,
      
      // Additional methods (for backward compatibility)
      validationState,
      updateFormData,
      validateAllFields,
      clearFieldError,
      isFormValid,
      updateFileUploadState,
      updateFromSubjectLinesState,
      resetForm
    }
  }

================================================================================
FILE: lib/creativeClient.ts
================================================================================

  import { API_ENDPOINTS } from '@/constants/apiEndpoints';

  export async function saveCreative(body: Record<string, unknown>) {
    const r = await fetch(API_ENDPOINTS.CREATIVE_SAVE, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!r.ok) throw new Error("Save failed");
    return r.json();
  }

  export async function deleteCreativeApi(arg: { fileUrl?: string; creativeId?: string }) {
    const r = await fetch(API_ENDPOINTS.CREATIVE_DELETE, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(arg),
    });
    if (!r.ok) throw new Error("Delete failed");
    return r.json();
  }

  export async function saveHtml(arg: { fileUrl: string; html: string; newFileName?: string }) {
    const r = await fetch(API_ENDPOINTS.CREATIVE_SAVE_HTML, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(arg),
    });
    if (!r.ok) throw new Error("Save HTML failed");
    return r.json();
  }

  export async function renameCreative(arg: { creativeId?: string; fileUrl?: string; newName: string }) {
    const r = await fetch(API_ENDPOINTS.CREATIVE_RENAME, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(arg),
    });
    if (!r.ok) throw new Error("Rename failed");
    return r.json();
  }

  export async function saveCreativeMetadata(arg: {
    creativeId: string;
    fromLines?: string;
    subjectLines?: string;
    proofreadingData?: unknown;
    htmlContent?: string;
    metadata?: Record<string, unknown>;
  }) {
    const r = await fetch(API_ENDPOINTS.CREATIVE_SAVE_METADATA, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(arg),
    });
    if (!r.ok) throw new Error("Save metadata failed");
    return r.json();
  }

  export async function getCreativeMetadata(creativeId: string) {
    const r = await fetch(`${API_ENDPOINTS.CREATIVE_GET_METADATA}?creativeId=${creativeId}`, {
      method: "GET",
      headers: { "Content-Type": "application/json" },
    });
    if (!r.ok) throw new Error("Get metadata failed");
    return r.json();
  }

================================================================================
FILE: lib/filesClient.ts
================================================================================

  import { API_ENDPOINTS, buildFileUrl } from '@/constants/apiEndpoints';

  export async function deleteFileById(id: string) {
    const r = await fetch(buildFileUrl(id), { method: 'DELETE' });
    if (!r.ok) throw new Error('delete failed');
    return r.json();
  }

  export async function bulkDeleteByIds(ids: string[]) {
    const r = await fetch(API_ENDPOINTS.FILES_BULK_DELETE, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ids }),
    });
    if (!r.ok) throw new Error('bulk delete failed');
    return r.json();
  }

  export function parseIdsFromUrl(u: string) {
    try {
      if (u.includes('/api/files/')) {
        const m = u.match(/\/api\/files\/([^/]+)\/([^?#]+)/);
        if (m) return { id: decodeURIComponent(m[1]), name: decodeURIComponent(m[2]) };
      }
      if (u.includes('/api/uploads')) {
        const url = new URL(u, 'http://x');
        const id = url.searchParams.get('id') || '';
        const name = url.searchParams.get('name') || '';
        if (id && name) return { id, name };
      }
    } catch {}
    return { id: '', name: '' };
  }

================================================================================
FILE: lib/generationClient.ts
================================================================================

  import { API_ENDPOINTS } from '@/constants/apiEndpoints';

  export async function generateEmailContent(opts: {
    creativeType?: string;
    audience?: string;
    brandVoice?: string;
    industry?: string;
    campaignGoal?: string;
    notes?: string;
    sampleText?: string;
    maxFrom?: number;
    maxSubject?: number;
  }) {
    const r = await fetch(API_ENDPOINTS.GENERATE_EMAIL_CONTENT, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(opts),
    });
    if (!r.ok) {
      const err = await r.json().catch(() => ({}));
      throw new Error(err.error || `HTTP ${r.status}`);
    }
    return (await r.json()) as { fromLines: string[]; subjectLines: string[] };
}

================================================================================
FILE: hooks/useFileUpload.ts
================================================================================

import { useState, useCallback } from 'react';
  import { API_ENDPOINTS } from '@/constants/apiEndpoints';

interface UploadProgress {
  [key: string]: number;
}

interface UploadState {
  uploading: boolean;
  progress: UploadProgress;
  errors: Record<string, string>;
  uploadedFiles: string[];
}

export function useFileUpload() {
  const [state, setState] = useState<UploadState>({
    uploading: false,
    progress: {},
    errors: {},
    uploadedFiles: []
  });

  const uploadFile = useCallback(async (file: File, onProgress?: (progress: number) => void) => {
    const formData = new FormData();
    formData.append('file', file);
    
    setState(prev => ({
      ...prev,
      uploading: true,
      progress: { ...prev.progress, [file.name]: 0 }
    }));

    try {
      const xhr = new XMLHttpRequest();
      
      xhr.upload.addEventListener('progress', (event) => {
        if (event.lengthComputable) {
          const progress = Math.round((event.loaded / event.total) * 100);
          setState(prev => ({
            ...prev,
            progress: { ...prev.progress, [file.name]: progress }
          }));
          onProgress?.(progress);
        }
      });

      xhr.addEventListener('load', () => {
        if (xhr.status === 200) {
          const response = JSON.parse(xhr.responseText);
          setState(prev => ({
            ...prev,
            uploading: false,
            uploadedFiles: [...prev.uploadedFiles, response.filename],
            progress: { ...prev.progress, [file.name]: 100 }
          }));
        } else {
          throw new Error(`Upload failed: ${xhr.statusText}`);
        }
      });

      xhr.addEventListener('error', () => {
        setState(prev => ({
          ...prev,
          uploading: false,
          errors: { ...prev.errors, [file.name]: 'Upload failed' }
        }));
      });

      xhr.open('POST', API_ENDPOINTS.UPLOAD);
      xhr.send(formData);
    } catch (error) {
      setState(prev => ({
        ...prev,
        uploading: false,
        errors: { ...prev.errors, [file.name]: error instanceof Error ? error.message : 'Upload failed' }
      }));
    }
  }, []);

  const uploadZip = useCallback(async (file: File, onProgress?: (progress: number) => void) => {
    const formData = new FormData();
    formData.append('zip', file);
    
    setState(prev => ({
      ...prev,
      uploading: true,
      progress: { ...prev.progress, [file.name]: 0 }
    }));

    try {
      const xhr = new XMLHttpRequest();
      
      xhr.upload.addEventListener('progress', (event) => {
        if (event.lengthComputable) {
          const progress = Math.round((event.loaded / event.total) * 100);
          setState(prev => ({
            ...prev,
            progress: { ...prev.progress, [file.name]: progress }
          }));
          onProgress?.(progress);
        }
      });

      xhr.addEventListener('load', () => {
        if (xhr.status === 200) {
          const response = JSON.parse(xhr.responseText);
          setState(prev => ({
            ...prev,
            uploading: false,
            uploadedFiles: [...prev.uploadedFiles, ...response.files],
            progress: { ...prev.progress, [file.name]: 100 }
          }));
        } else {
          throw new Error(`Upload failed: ${xhr.statusText}`);
        }
      });

      xhr.addEventListener('error', () => {
        setState(prev => ({
          ...prev,
          uploading: false,
          errors: { ...prev.errors, [file.name]: 'Upload failed' }
        }));
      });

      xhr.open('POST', API_ENDPOINTS.UPLOAD_ZIP);
      xhr.send(formData);
    } catch (error) {
      setState(prev => ({
        ...prev,
        uploading: false,
        errors: { ...prev.errors, [file.name]: error instanceof Error ? error.message : 'Upload failed' }
      }));
    }
  }, []);

  const uploadUrl = useCallback(async (url: string) => {
    setState(prev => ({ ...prev, uploading: true }));

    try {
      const response = await fetch(API_ENDPOINTS.UPLOAD_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url })
      });

      if (!response.ok) {
        throw new Error(`Upload failed: ${response.statusText}`);
      }

      const result = await response.json();
      setState(prev => ({
        ...prev,
        uploading: false,
        uploadedFiles: [...prev.uploadedFiles, result.filename]
      }));

      return result;
    } catch (error) {
      setState(prev => ({
        ...prev,
        uploading: false,
        errors: { ...prev.errors, url: error instanceof Error ? error.message : 'Upload failed' }
      }));
      throw error;
    }
  }, []);

  const clearErrors = useCallback(() => {
    setState(prev => ({ ...prev, errors: {} }));
  }, []);

  const reset = useCallback(() => {
    setState({
      uploading: false,
      progress: {},
      errors: {},
      uploadedFiles: []
    });
  }, []);

  return {
    ...state,
    uploadFile,
    uploadZip,
    uploadUrl,
    clearErrors,
    reset
  };
}

================================================================================
FILE: hooks/index.ts
================================================================================

export { useFormValidation } from './useFormValidation';
export { useFileUpload } from './useFileUpload';

================================================================================
FILE: app/Form/Steps/PersonalDetails.tsx
================================================================================

  "use client"

  import React from 'react'
  import { Input } from '@/components/ui/input'
  import { Label } from '@/components/ui/label'
  import { ErrorMessage } from '@/components/ui/error-message'
  import { Constants } from '@/app/Constants/Constants'
  import { useFormValidation } from '@/hooks/useFormValidation'

interface PersonalDetailsProps {
  formData: {
      affiliateId: string;
      companyName: string;
    firstName: string;
    lastName: string;
  };
    onDataChange: (data: Partial<PersonalDetailsProps['formData']>) => void;
    validationHook?: ReturnType<typeof useFormValidation>;
}

  const PersonalDetails: React.FC<PersonalDetailsProps> = ({ 
  formData,
    onDataChange,
    validationHook 
  }) => {

    // Filter only the personal detail fields from Constants
    const personalFields = Constants.formFields.filter(field => 
      ['affiliateId', 'companyName', 'firstName', 'lastName'].includes(field.name)
    )

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const { name, value } = e.target
      
      // Block numbers for firstName and lastName fields
      if ((name === 'firstName' || name === 'lastName') && /\d/.test(value)) {
        return // Don't update if numbers are detected
      }
      
      // Update form data
      onDataChange({ [name]: value })
      
      // Trigger validation if validation hook is provided
      if (validationHook) {
        validationHook.handleFieldChange(name, value, true)
      }
    }

    const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
      const { name } = e.target
      
      // Mark field as touched if validation hook is provided
      if (validationHook) {
        validationHook.handleFieldBlur(name)
      }
    }

    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
      const { name } = e.currentTarget
      
      // Prevent number keys from being pressed for firstName and lastName fields
      if ((name === 'firstName' || name === 'lastName') && /\d/.test(e.key)) {
        e.preventDefault()
        return
      }
    }

    const getFieldError = (fieldName: string): string => {
      if (!validationHook) return ''
      return validationHook.getFieldErrorMessage(fieldName)
    }

    const hasFieldError = (fieldName: string): boolean => {
      if (!validationHook) return false
      return validationHook.hasFieldError(fieldName)
    }

    const isFieldTouched = (fieldName: string): boolean => {
      if (!validationHook) return false
      return validationHook.isFieldTouched(fieldName)
    }

  return (
    <div className="space-y-6">
        
        {/* Affiliate ID and Company Name - Single Column */}
        <div className="space-y-4">
          {personalFields.slice(0, 2).map((field) => (
            <div key={field.name} className="space-y-2">
              <Label htmlFor={field.name}>{field.label}</Label>
          <Input
                id={field.name}
                name={field.name}
                type={field.type}
                placeholder={field.placeholder}
                value={formData[field.name as keyof typeof formData]}
                onChange={handleChange}
                onBlur={handleBlur}
                onKeyDown={handleKeyDown}
                className={hasFieldError(field.name) ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : ''}
              />
              <ErrorMessage 
                message={getFieldError(field.name)}
                show={isFieldTouched(field.name) && hasFieldError(field.name)}
              />
            </div>
          ))}
        </div>

        {/* First Name and Last Name - Responsive Layout */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {personalFields.slice(2, 4).map((field) => (
            <div key={field.name} className="space-y-2">
              <Label htmlFor={field.name}>{field.label}</Label>
          <Input
                id={field.name}
                name={field.name}
                type={field.type}
                placeholder={field.placeholder}
                value={formData[field.name as keyof typeof formData]}
                onChange={handleChange}
                onBlur={handleBlur}
                onKeyDown={handleKeyDown}
                pattern="[a-zA-Z\s'-]+"
                inputMode="text"
                autoComplete={field.name === 'firstName' ? 'given-name' : 'family-name'}
                className={hasFieldError(field.name) ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : ''}
              />
              <ErrorMessage 
                message={getFieldError(field.name)}
                show={isFieldTouched(field.name) && hasFieldError(field.name)}
              />
        </div>
          ))}
      </div>
    </div>
    )
}

  export default PersonalDetails

================================================================================
FILE: app/Form/Steps/ContactDetails.tsx
================================================================================

  import { Constants } from '@/app/Constants/Constants'
  import { API_ENDPOINTS } from '@/constants/apiEndpoints'
  import { Button } from '@/components/ui/button'
  import { Input } from '@/components/ui/input'
  import { Label } from '@/components/ui/label'
  import { ErrorMessage } from '@/components/ui/error-message'
  import React, { useState, useCallback, useRef } from 'react'
  import { TELEGRAM_BOT_URL } from '@/constants'
  import { useFormValidation } from '@/hooks/useFormValidation'

interface ContactDetailsProps {
  formData: {
    email: string;
    telegramId: string;
  };
    onDataChange: (data: Partial<ContactDetailsProps['formData']>) => void;
    validationHook?: ReturnType<typeof useFormValidation>;
}

  const ContactDetails: React.FC<ContactDetailsProps> = ({ 
  formData,
    onDataChange,
    validationHook 
  }) => {
    
    const [isTelegramFocused, setIsTelegramFocused] = useState(false)
    const [isVerifying, setIsVerifying] = useState(false)
    const [isVerified, setIsVerified] = useState(false)
    const [verificationAttempted, setVerificationAttempted] = useState(false)
    const [verificationError, setVerificationError] = useState<string | null>(null)
    
    // Debounce verification attempts
    const verifyTimeoutRef = useRef<NodeJS.Timeout | null>(null)
    const lastVerifyTimeRef = useRef<number>(0)

  const contactFields = Constants.formFields.filter(field =>
    ['email', 'telegramId'].includes(field.name)
  )

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    
    // Special handling for Telegram ID field
    if (name === 'telegramId') {
      let processedValue = value
      
      // If user is typing and value doesn't start with @, add it
      if (value && !value.startsWith('@')) {
        processedValue = '@' + value
      }
      
      // If user deletes everything, don't add @
      if (value === '') {
        processedValue = ''
      }
      
      onDataChange({ [name]: processedValue })
      
      // Trigger validation if validation hook is provided
      if (validationHook) {
        validationHook.handleFieldChange(name, processedValue, false) // Telegram is optional
      }
    } else {
      // Normal handling for other fields
      onDataChange({ [name]: value })
      
      // Trigger validation if validation hook is provided
      if (validationHook) {
        validationHook.handleFieldChange(name, value, true) // Email is required
      }
    }
  }

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    const { name, value } = e.currentTarget
    
    // Handle backspace for Telegram field
    if (name === 'telegramId' && e.key === 'Backspace') {
      // If current value is just "@" and user presses backspace, prevent deletion
      if (value === '@') {
        e.preventDefault()
        return
      }
      
      // If user is trying to delete the "@" symbol, prevent it
      if (value.length === 2 && value.startsWith('@')) {
        e.preventDefault()
        onDataChange({ [name]: '@' })
        return
      }
    }
  }

  const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {
    const { name } = e.target
    
    // Track focus state for Telegram field
    if (name === 'telegramId') {
      setIsTelegramFocused(true)
      
      // Add @ when focusing on Telegram field if it's empty
      if (!formData.telegramId) {
        onDataChange({ [name]: '@' })
      }
    }
  }

  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    
    // Track focus state for Telegram field
    if (name === 'telegramId') {
      setIsTelegramFocused(false)
      
      // Remove @ when losing focus if user hasn't entered anything meaningful
      if (value === '@' || value === '') {
        onDataChange({ [name]: '' })
      }
    }
    
    // Mark field as touched if validation hook is provided
    if (validationHook) {
      validationHook.handleFieldBlur(name)
    }
  }

  const handleVerify = useCallback(async () => {
    if (!formData.telegramId || formData.telegramId === '@') return
    
    // Debounce verification attempts (prevent rapid clicking)
    const now = Date.now()
    const timeSinceLastVerify = now - lastVerifyTimeRef.current
    const minInterval = 2000 // 2 seconds between attempts
    
    if (timeSinceLastVerify < minInterval) {
      setVerificationError(`Please wait ${Math.ceil((minInterval - timeSinceLastVerify) / 1000)} seconds before trying again`)
      return
    }
    
    // Clear any existing timeout
    if (verifyTimeoutRef.current) {
      clearTimeout(verifyTimeoutRef.current)
    }
    
    setIsVerifying(true)
    setVerificationAttempted(true)
    setVerificationError(null)
    lastVerifyTimeRef.current = now
    
    try {
      // First, poll for any pending updates
      const pollResponse = await fetch(API_ENDPOINTS.TELEGRAM_POLL, { 
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      })
      
      if (!pollResponse.ok) {
        throw new Error('Failed to poll for updates')
      }

      // Then verify the Telegram ID
      const verifyResponse = await fetch(API_ENDPOINTS.TELEGRAM_VERIFY, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ telegramId: formData.telegramId }),
      })
      
      if (!verifyResponse.ok) {
        const errorText = await verifyResponse.text()
        throw new Error(`Verification failed: ${verifyResponse.status} ${errorText}`)
      }
      
      const data = await verifyResponse.json()
      
      // Ensure we get the expected response shape
      if (typeof data.verified !== 'boolean') {
        throw new Error('Invalid response format from verification endpoint')
      }
      
      setIsVerified(data.verified)
      
      if (!data.verified) {
        setVerificationError('Telegram ID not found. Make sure you sent /start to the bot first.')
      }
    } catch (err) {
      console.error('Verification failed:', err)
      setIsVerified(false)
      setVerificationError(err instanceof Error ? err.message : 'Verification failed. Please try again.')
    } finally {
      setIsVerifying(false)
    }
  }, [formData.telegramId])

  const getFieldError = (fieldName: string): string => {
    if (!validationHook) return ''
    return validationHook.getFieldErrorMessage(fieldName)
  }

  const hasFieldError = (fieldName: string): boolean => {
    if (!validationHook) return false
    return validationHook.hasFieldError(fieldName)
  }

  const isFieldTouched = (fieldName: string): boolean => {
    if (!validationHook) return false
    return validationHook.isFieldTouched(fieldName)
  }

  return (
    <div className="space-y-6">
        <div className="space-y-4">
          {contactFields.map((field) => (
            <div key={field.name} className="space-y-2">
              <Label htmlFor={field.name}>{field.label}</Label>
              
              {/* Custom input container for Telegram field with verify button */}
              {field.name === 'telegramId' ? (
                <div className="relative">
          <Input
                    id={field.name}
                    name={field.name}
                    type={field.type}
                    placeholder={field.placeholder}
                    value={formData[field.name as keyof typeof formData]}
                    onChange={handleChange}
                    onFocus={handleFocus}
                    onBlur={handleBlur}
                    onKeyDown={handleKeyDown}
                    className={`pr-20 ${hasFieldError(field.name) ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : ''}`}
                  />
                  <Button
                    variant="outline"
                    size="sm"
                    type="button"
                    onClick={handleVerify}
                    disabled={isVerifying || isVerified || !formData.telegramId || formData.telegramId === '@'}
                    className="absolute right-2 top-1/2 transform -translate-y-1/2 h-8 px-3 text-xs"
                  >
                    {isVerifying ? (
                      <div className="flex items-center gap-2">
                        <div className="w-3 h-3 border-2 border-primary-500 border-t-transparent rounded-full animate-spin"></div>
                        <span>Verifying...</span>
                      </div>
                    ) : isVerified ? (
                      <div className="flex items-center gap-2 text-success-dark">
                        <span>✅</span>
                        <span>Verified</span>
                      </div>
                    ) : (
                      'Verify'
                    )}
                  </Button>
        </div>
              ) : (
          <Input
                  id={field.name}
                  name={field.name}
                  type={field.type}
                  placeholder={field.placeholder}
                  value={formData[field.name as keyof typeof formData]}
                  onChange={handleChange}
                  onFocus={handleFocus}
                  onBlur={handleBlur}
                  onKeyDown={handleKeyDown}
                  className={hasFieldError(field.name) ? 'border-red-500 focus:border-red-500 focus:ring-red-500' : ''}
                />
              )}
              
              {/* Error Message */}
              <ErrorMessage 
                message={getFieldError(field.name)}
                show={isFieldTouched(field.name) && hasFieldError(field.name)}
              />
              
              {/* Show tip for Telegram field only when focused */}
              {field.name === 'telegramId' && isTelegramFocused && (
                <p className="text-xs text-gray-500 mt-1">
                  💡 Enter your Telegram ID exactly as it appears - it&apos;s case sensitive
                </p>
              )}
              
              {/* Show verification error */}
              {field.name === 'telegramId' && verificationError && (
                <div className="mt-3 p-3 bg-red-50 border border-red-200 rounded-md">
                  <p className="text-sm text-red-600">{verificationError}</p>
        </div>
              )}
              
              {/* Show verification steps box for Telegram field when verification was attempted and failed */}
              {field.name === 'telegramId' && verificationAttempted && !isVerifying && !isVerified && !verificationError && (
                <div className="mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded-md">
                  <h4 className="text-sm font-medium text-yellow-800 mb-2">📋 Steps to Verify Your Telegram ID:</h4>
                  <ol className="text-xs text-yellow-700 space-y-1 list-decimal list-inside mb-3">
                    <li>Click on Start Bot Button</li>
                    <li>Send /start to the bot</li>
                    <li>Come back and Verify again</li>
                  </ol>
                  <Button asChild variant="outline" size="xs"
                    className="text-xs w-max border-yellow-300 text-yellow-700 hover:bg-yellow-200">
                    <a href={TELEGRAM_BOT_URL} target="_blank" rel="noopener noreferrer">Start Bot</a>
                  </Button>
        </div>
      )}
    </div>
          ))}
        </div>  
      </div>
    )
}

  export default ContactDetails

================================================================================
FILE: app/Form/Steps/CreativeDetails.tsx
================================================================================

"use client";

import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { ValidationSummary } from "@/components/ui/validation-summary";

interface CreativeDetailsProps {
  formData: {
    creativeType: string;
    description: string;
    targetAudience: string;
    campaignGoals: string;
    budget: string;
    timeline: string;
    additionalNotes: string;
  };
  errors: Record<string, string>;
  onInputChange: (field: string, value: string) => void;
  validateField: (field: string, value: string) => void;
}

export default function CreativeDetails({
  formData,
  errors,
  onInputChange,
  validateField,
}: CreativeDetailsProps) {
  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-2xl font-semibold text-gray-900 mb-2">
          Creative Details
        </h2>
        <p className="text-gray-600">
          Tell us about your creative project and requirements.
        </p>
      </div>

      <div className="space-y-4">
        <div className="space-y-2">
          <Label htmlFor="creativeType">Creative Type *</Label>
          <Select
            value={formData.creativeType}
            onValueChange={(value) => onInputChange("creativeType", value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select creative type" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="single">Single Creative</SelectItem>
              <SelectItem value="multiple">Multiple Creatives</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="space-y-2">
          <Label htmlFor="description">Project Description *</Label>
          <Textarea
            id="description"
            value={formData.description}
            onChange={(e) => onInputChange("description", e.target.value)}
            onBlur={(e) => validateField("description", e.target.value)}
            placeholder="Describe your creative project in detail..."
            rows={4}
            className={errors.description ? "border-red-500" : ""}
          />
          {errors.description && (
            <p className="text-sm text-red-600">{errors.description}</p>
          )}
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label htmlFor="targetAudience">Target Audience</Label>
            <Input
              id="targetAudience"
              type="text"
              value={formData.targetAudience}
              onChange={(e) => onInputChange("targetAudience", e.target.value)}
              placeholder="e.g., Young professionals, 25-35"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="campaignGoals">Campaign Goals</Label>
            <Input
              id="campaignGoals"
              type="text"
              value={formData.campaignGoals}
              onChange={(e) => onInputChange("campaignGoals", e.target.value)}
              placeholder="e.g., Brand awareness, Lead generation"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="budget">Budget Range</Label>
            <Select
              value={formData.budget}
              onValueChange={(value) => onInputChange("budget", value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select budget range" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="under-1k">Under $1,000</SelectItem>
                <SelectItem value="1k-5k">$1,000 - $5,000</SelectItem>
                <SelectItem value="5k-10k">$5,000 - $10,000</SelectItem>
                <SelectItem value="10k-25k">$10,000 - $25,000</SelectItem>
                <SelectItem value="25k-50k">$25,000 - $50,000</SelectItem>
                <SelectItem value="over-50k">Over $50,000</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="timeline">Timeline</Label>
            <Select
              value={formData.timeline}
              onValueChange={(value) => onInputChange("timeline", value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select timeline" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="1-2-weeks">1-2 weeks</SelectItem>
                <SelectItem value="2-4-weeks">2-4 weeks</SelectItem>
                <SelectItem value="1-2-months">1-2 months</SelectItem>
                <SelectItem value="2-3-months">2-3 months</SelectItem>
                <SelectItem value="3-6-months">3-6 months</SelectItem>
                <SelectItem value="over-6-months">Over 6 months</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>

        <div className="space-y-2">
          <Label htmlFor="additionalNotes">Additional Notes</Label>
          <Textarea
            id="additionalNotes"
            value={formData.additionalNotes}
            onChange={(e) => onInputChange("additionalNotes", e.target.value)}
            placeholder="Any additional information or special requirements..."
            rows={3}
          />
        </div>
      </div>

      {Object.keys(errors).length > 0 && (
        <ValidationSummary errors={errors} />
      )}
    </div>
  );
}

================================================================================
FILE: constants/fileUpload.ts
================================================================================

export const FILE_UPLOAD_CONSTANTS = {
  // File size limits
  MAX_FILE_SIZE: 100 * 1024 * 1024, // 100MB
  MAX_IMAGE_SIZE: 10 * 1024 * 1024, // 10MB
  MAX_ZIP_SIZE: 50 * 1024 * 1024, // 50MB
  MAX_HTML_SIZE: 5 * 1024 * 1024, // 5MB

  // Allowed file types
  ALLOWED_IMAGE_TYPES: [
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/svg+xml'
  ],
  ALLOWED_HTML_TYPES: [
    'text/html',
    'application/xhtml+xml'
  ],
  ALLOWED_ZIP_TYPES: [
    'application/zip',
    'application/x-zip-compressed'
  ],
  ALLOWED_ALL_TYPES: [
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/svg+xml',
    'text/html',
    'application/xhtml+xml',
    'application/zip',
    'application/x-zip-compressed'
  ],

  // Allowed file extensions
  ALLOWED_EXTENSIONS: [
    '.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg',
    '.html', '.htm',
    '.zip'
  ],

  // Upload directories
  UPLOAD_DIR: './uploads',
  IMAGES_DIR: './uploads/images',
  HTML_DIR: './uploads/html',
  ZIP_DIR: './uploads/zip',
  TEMP_DIR: './uploads/temp',

  // Security settings
  SCAN_VIRUSES: true,
  VALIDATE_FILE_TYPES: true,
  CHECK_FILE_HEADERS: true,
  MAX_FILES_PER_UPLOAD: 100,
  MAX_FILES_PER_ZIP: 1000,

  // Rate limiting
  MAX_UPLOADS_PER_HOUR: 50,
  MAX_UPLOADS_PER_DAY: 500,
  UPLOAD_COOLDOWN_MS: 1000, // 1 second between uploads

  // File processing
  GENERATE_THUMBNAILS: true,
  THUMBNAIL_SIZE: 200,
  COMPRESS_IMAGES: false,
  MAX_IMAGE_DIMENSIONS: {
    width: 4096,
    height: 4096
  },

  // Metadata
  STORE_METADATA: true,
  EXTRACT_EXIF: true,
  GENERATE_CHECKSUMS: true,
  HASH_ALGORITHM: 'sha256' as const,

  // Cleanup
  AUTO_CLEANUP: true,
  CLEANUP_INTERVAL_HOURS: 24,
  MAX_FILE_AGE_DAYS: 30,
  QUARANTINE_SUSPICIOUS: true
};

export const UPLOAD_STATUS = {
  PENDING: 'pending',
  UPLOADING: 'uploading',
  PROCESSING: 'processing',
  COMPLETED: 'completed',
  FAILED: 'failed',
  QUARANTINED: 'quarantined',
  DELETED: 'deleted'
} as const;

export const UPLOAD_ERROR_CODES = {
  FILE_TOO_LARGE: 'FILE_TOO_LARGE',
  INVALID_FILE_TYPE: 'INVALID_FILE_TYPE',
  VIRUS_DETECTED: 'VIRUS_DETECTED',
  CORRUPTED_FILE: 'CORRUPTED_FILE',
  UPLOAD_LIMIT_EXCEEDED: 'UPLOAD_LIMIT_EXCEEDED',
  STORAGE_FULL: 'STORAGE_FULL',
  PERMISSION_DENIED: 'PERMISSION_DENIED',
  NETWORK_ERROR: 'NETWORK_ERROR',
  UNKNOWN_ERROR: 'UNKNOWN_ERROR'
} as const;

export const FILE_PROCESSING_OPTIONS = {
  // Image processing
  RESIZE_IMAGES: true,
  MAX_WIDTH: 1920,
  MAX_HEIGHT: 1080,
  QUALITY: 85,
  FORMAT: 'jpeg' as const,

  // ZIP processing
  EXTRACT_ZIP: true,
  VALIDATE_ZIP_CONTENTS: true,
  MAX_ZIP_DEPTH: 5,
  ALLOW_PASSWORD_PROTECTED: false,

  // HTML processing
  SANITIZE_HTML: true,
  REMOVE_SCRIPTS: true,
  ALLOW_IFRAMES: false,
  MAX_HTML_SIZE: 1024 * 1024, // 1MB

  // Security
  SCAN_CONTENTS: true,
  VALIDATE_URLS: true,
  CHECK_EXTERNAL_LINKS: true,
  BLOCK_SUSPICIOUS_DOMAINS: true
};

export const UPLOAD_NOTIFICATIONS = {
  SEND_EMAIL_CONFIRMATION: true,
  SEND_UPLOAD_SUMMARY: true,
  NOTIFY_ADMIN_ON_ERROR: true,
  NOTIFY_USER_ON_SUCCESS: true,
  INCLUDE_FILE_PREVIEW: true,
  INCLUDE_PROCESSING_TIME: true
};

export const STORAGE_OPTIONS = {
  // Local storage
  USE_LOCAL_STORAGE: true,
  LOCAL_STORAGE_PATH: './uploads',
  CREATE_SUBDIRECTORIES: true,
  USE_DATE_BASED_FOLDERS: true,

  // Cloud storage (future)
  USE_CLOUD_STORAGE: false,
  CLOUD_PROVIDER: 'aws' as const, // 'aws', 'gcp', 'azure'
  CLOUD_BUCKET: '',
  CLOUD_REGION: '',

  // Backup
  ENABLE_BACKUP: false,
  BACKUP_INTERVAL_HOURS: 24,
  BACKUP_RETENTION_DAYS: 7,

  // Compression
  COMPRESS_STORAGE: false,
  COMPRESSION_LEVEL: 6,
  COMPRESS_AFTER_DAYS: 7
};

export const VALIDATION_RULES = {
  // File name validation
  ALLOWED_CHARACTERS: /^[a-zA-Z0-9._-]+$/,
  MAX_FILENAME_LENGTH: 255,
  MIN_FILENAME_LENGTH: 1,

  // Content validation
  MAX_FILE_CONTENT_SIZE: 100 * 1024 * 1024, // 100MB
  ALLOWED_HTML_TAGS: [
    'div', 'span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'ul', 'ol', 'li', 'a', 'img', 'table', 'tr', 'td', 'th',
    'strong', 'em', 'b', 'i', 'u', 'br', 'hr'
  ],
  BLOCKED_HTML_ATTRIBUTES: [
    'onclick', 'onload', 'onerror', 'onmouseover', 'onmouseout',
    'onfocus', 'onblur', 'onchange', 'onsubmit', 'onreset'
  ],

  // Virus scanning
  SCAN_FILE_HEADERS: true,
  SCAN_FILE_CONTENTS: true,
  SCAN_ARCHIVES: true,
  MAX_SCAN_SIZE: 50 * 1024 * 1024, // 50MB
  SCAN_TIMEOUT_MS: 30000 // 30 seconds
};

export const ERROR_MESSAGES = {
  [UPLOAD_ERROR_CODES.FILE_TOO_LARGE]: 'File size exceeds the maximum allowed limit',
  [UPLOAD_ERROR_CODES.INVALID_FILE_TYPE]: 'File type is not allowed',
  [UPLOAD_ERROR_CODES.VIRUS_DETECTED]: 'File failed security scan',
  [UPLOAD_ERROR_CODES.CORRUPTED_FILE]: 'File appears to be corrupted',
  [UPLOAD_ERROR_CODES.UPLOAD_LIMIT_EXCEEDED]: 'Upload limit exceeded',
  [UPLOAD_ERROR_CODES.STORAGE_FULL]: 'Storage is full',
  [UPLOAD_ERROR_CODES.PERMISSION_DENIED]: 'Permission denied',
  [UPLOAD_ERROR_CODES.NETWORK_ERROR]: 'Network error occurred',
  [UPLOAD_ERROR_CODES.UNKNOWN_ERROR]: 'An unknown error occurred'
};

export const SUCCESS_MESSAGES = {
  FILE_UPLOADED: 'File uploaded successfully',
  ZIP_PROCESSED: 'ZIP file processed successfully',
  FILES_EXTRACTED: 'Files extracted successfully',
  THUMBNAIL_GENERATED: 'Thumbnail generated successfully',
  METADATA_EXTRACTED: 'File metadata extracted successfully'
};

================================================================================
FILE: app/api/upload/route.ts
================================================================================

  import { NextRequest, NextResponse } from 'next/server';
  import { saveBuffer, getFilePath } from '@/lib/fileStorage';
  import { randomUUID } from 'crypto';
  import JSZip from 'jszip';
  import { makeImagePreview } from '@/lib/preview';

  export const runtime = 'nodejs';

  export async function POST(req: NextRequest) {
    const form = await req.formData();
    const file = form.get('file') as File | null;
    const smartDetection = form.get('smartDetection') === 'true';
    
    if (!file) return NextResponse.json({ error: 'file required' }, { status: 400 });

    const arrayBuf = await file.arrayBuffer();
    const buf = Buffer.from(arrayBuf);

    if ((file.type || '').includes('zip') || /\.zip$/i.test(file.name)) {
      const zipId = randomUUID();
      
      if (smartDetection) {
        const zip = await JSZip.loadAsync(buf);

        const normalize = (p: string) => p.replace(/\\/g, "/").replace(/\.\.(\/|\\)/g, "").replace(/^\/+/, "");
        const isImg = (n: string) => /\.(png|jpe?g|gif|webp|svg)$/i.test(n);
        const isHtml = (n: string) => /\.html?$/i.test(n);
        const isZip  = (n: string) => /\.zip$/i.test(n);

        const writeFile = async (relPath: string, data: Buffer) => {
          const abs = await getFilePath(zipId, relPath);
          await (await import("fs/promises")).mkdir((await import("path")).dirname(abs), { recursive: true });
          await (await import("fs/promises")).writeFile(abs, data);
          return abs;
        };

        async function makeThumbIfImage(rel: string, data: Buffer) {
          if (!isImg(rel)) return undefined;
          const thumbRel = `thumbs/${rel.replace(/\//g, "__")}.jpg`;
          try {
            const sharp = (await import("sharp")).default;
            const thumb = await sharp(data).resize(480, 480, { fit: "inside", withoutEnlargement: true }).jpeg({ quality: 80 }).toBuffer();
            await writeFile(thumbRel, thumb);
            return thumbRel;
          } catch { return undefined; }
        }

        async function traverseZip(zipObj: JSZip, prefix = "", depth = 0, out: Array<{
          id: string; name: string; type: "image"|"html"|"other"; size: number; url: string; previewUrl?: string; html?: boolean;
        }> = []) {
          if (depth > Number(process.env.ZIP_MAX_DEPTH ?? "2")) return out;
          const baseUrl = `/api/files/${encodeURIComponent(zipId)}/`;
          for (const entry of Object.values(zipObj.files)) {
            if (entry.dir) continue;
            const rel0 = normalize(entry.name);
            const rel = normalize(prefix + rel0);
            const lower = rel.toLowerCase();

            if (isZip(lower)) {
              try {
                const innerBuf = Buffer.from(await entry.async("nodebuffer"));
                const inner = await JSZip.loadAsync(innerBuf);
                const subPrefix = rel.replace(/\.zip$/i, "") + "/";
                await traverseZip(inner, subPrefix, depth + 1, out);
              } catch {}
              continue;
            }

            const data = Buffer.from(await entry.async("nodebuffer"));
            await writeFile(rel, data);

            const item = {
              id: zipId,
              name: rel,
              type: isImg(lower) ? "image" : isHtml(lower) ? "html" : "other",
              size: data.length,
              url: baseUrl + rel,
              html: isHtml(lower) || undefined,
            } as {
              id: string; name: string; type: "image"|"html"|"other"; size: number; url: string; previewUrl?: string; html?: boolean;
            };

            if (item.type === "image") {
              const thumbRel = await makeThumbIfImage(rel, data);
              item.previewUrl = thumbRel ? baseUrl + thumbRel : item.url;
            }

            out.push(item);
          }
          return out;
        }

        const allItems = await traverseZip(zip);
        const hasHtml = allItems.some(i => i.type === "html");
        const items = hasHtml ? allItems.filter(i => i.type !== "image") : allItems;

        const images = items.filter(i => i.type === "image").length;
        const htmls  = items.filter(i => i.type === "html").length;
        const others = items.filter(i => i.type === "other").length;
        const isSingleCreative = (images + htmls) === 1;

        // Return the analysis in the format expected by the frontend
        return NextResponse.json({
          success: true,
          zipAnalysis: {
            uploadId: zipId,
            isSingleCreative,
            items,
            counts: { images, htmls, others, total: items.length },
          }
        });
      }
      
      const zip = await JSZip.loadAsync(buf);


      const extractedFiles: Array<{
        fileId: string;
        fileName: string;
        fileUrl: string;
        fileSize: number;
        fileType: string;
        originalPath: string;
        previewUrl?: string; 
      }> = [];
      const entries = Object.values(zip.files);
      for (const entry of entries) {
        if (entry.dir) continue;
        const content = await entry.async('nodebuffer');
        const saved = await saveBuffer(content, entry.name);
        
        const fileType = guessType(entry.name);
        const isImage = /\.(jpg|jpeg|png|gif|webp)$/i.test(entry.name);
        
        let previewUrl: string | undefined;
        if (isImage) {
          try {
            const thumb = await makeImagePreview(content, 400);
            if (thumb) {
              const prev = await saveBuffer(thumb, `preview_${saved.fileName}.jpg`);
              previewUrl = `/api/files/${prev.id}/${encodeURIComponent(prev.fileName)}`;
            }
          } catch (error) {
            console.error('Thumbnail generation failed:', error);
          }
        }

        extractedFiles.push({
          fileId: saved.id,
          fileName: entry.name.split('/').pop() || entry.name,
          fileUrl: `/api/files/${saved.id}/${encodeURIComponent(saved.fileName)}`,
          fileSize: content.length,
          fileType: fileType,
          originalPath: entry.name,
          previewUrl
        });
      }
      return NextResponse.json({
        success: true,
        zipFileId: zipId,
        extractedFiles,
        totalFiles: extractedFiles.length,
        extractionDate: new Date().toISOString()
      });
    }

    const saved = await saveBuffer(buf, file.name);
    const fileUrl = `/api/files/${saved.id}/${encodeURIComponent(saved.fileName)}`;

    let previewUrl: string | undefined;
    if (/\.(jpg|jpeg|png|gif|webp)$/i.test(file.name)) {
      const thumb = await makeImagePreview(buf, 400);
      if (thumb) {
        const prev = await saveBuffer(thumb, `preview_${saved.fileName}.jpg`);
        previewUrl = `/api/files/${prev.id}/${encodeURIComponent(prev.fileName)}`;
      }
    }

    return NextResponse.json({
      success: true,
      filename: saved.fileName,
      file: {
        fileId: saved.id,
        fileName: saved.fileName,
        fileUrl,
        fileSize: buf.length,
        fileType: file.type || guessType(file.name),
        uploadDate: new Date().toISOString(),
        previewUrl
      }
    });
  }

  function guessType(name: string) {
    const n = name.toLowerCase();
    if (/\.(png|jpg|jpeg|gif|webp)$/.test(n)) return 'image/' + n.split('.').pop();
    if (/\.html?$/.test(n)) return 'text/html';
    return 'application/octet-stream';
  }

================================================================================
FILE: app/api/upload-zip/route.ts
================================================================================

  import { NextResponse } from 'next/server';
  import { detectFileType } from '@/lib/security/fileType';
  import { previewZipCentralDirectory } from '@/lib/zipPreview';
  import { processZipBuffer } from '@/lib/zip';
  import { extractEncryptedZipBuffer } from '@/lib/zipPassword';
  import { sendToLoggingService } from '@/lib/logging';
  import { rateLimit } from '@/lib/rateLimit';
  import { progressStart, progressUpdate, progressDone, progressError } from '@/lib/progressStore';

  const ALLOW = new Set([
    'image/png','image/jpeg','image/gif','image/webp','image/svg+xml',
    'text/html','application/pdf',
  ]);
  const MAX_FILES = Number(process.env.ZIP_MAX_FILES ?? 200);
  const MAX_TOTAL = Number(process.env.ZIP_MAX_TOTAL ?? 300 * 1024 * 1024);
  const MAX_DEPTH = Number(process.env.ZIP_MAX_DEPTH ?? 2);
  const PER_FILE_MAX = Number(process.env.ZIP_PER_FILE_MAX ?? 50 * 1024 * 1024);
  const ENABLE_SCAN = process.env.ENABLE_VIRUS_SCAN === '1';
  const ENCRYPTED_POLICY: 'skip' | 'error' | 'attempt' = (process.env.ZIP_ENCRYPTED_POLICY as 'skip' | 'error' | 'attempt') ?? 'skip';

  export const dynamic = 'force-dynamic';

  export async function POST(req: Request) {
    const ip = (req.headers.get('x-forwarded-for') || '').split(',')[0].trim() || 'unknown-ip';
    if (!rateLimit(`zip:${ip}`, { capacity: 10, refillPerSec: 0.2 })) {
      return NextResponse.json({ error: 'Rate limit exceeded' }, { status: 429 });
    }

    const form = await req.formData();
    let file = (form.get('file') || form.get('zip')) as File | null;
    if (!file) return NextResponse.json({ error: 'No file' }, { status: 400 });

    const uploadId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    progressStart(uploadId, { name: file.name, size: file.size });
    
    try {
      progressUpdate(uploadId, 1, 'reading');

      const ab = await file.arrayBuffer();
      const buf = Buffer.from(ab);

      const head = await detectFileType(buf, file.name);
      if (head.mime !== 'application/zip') {
        progressError(uploadId, 'Not a ZIP', 0);
        return NextResponse.json({ error: 'Not a ZIP archive' }, { status: 415 });
      }

      progressUpdate(uploadId, 5, 'previewing');
      const preview = previewZipCentralDirectory(buf);
      if (!preview) {
        progressError(uploadId, 'EOCD not found', 5);
        return NextResponse.json({ error: 'Failed to parse ZIP (EOCD not found)' }, { status: 422 });
      }

      const encryptedEntries = preview.entries.filter(e => e.encrypted && !e.isDirectory);
      const hasEncrypted = encryptedEntries.length > 0;
      const compression = {
        totalCompressedBytes: preview.totals.compressed,
        totalUncompressedBytes: preview.totals.uncompressed,
        overallCompressionRatio: preview.totals.overallRatio,
        entryCount: preview.totals.files + preview.totals.dirs,
        highExpansionEntries: preview.suspicious.highExpansionEntries,
        highOverallExpansion: preview.suspicious.highOverallExpansion,
      };

      const extracted: Array<{
        fileId: string;
        fileName: string;
        fileUrl: string;
        fileSize: number;
        fileType: string;
        hash: string;
        depth: number;
        encrypted?: boolean;
      }> = [];
      const skipped: Array<{
        path?: string;
        reason: string;
      }> = [];

      
      const password = req.headers.get('x-zip-password') || undefined;
      if (hasEncrypted) {
        if (ENCRYPTED_POLICY === 'error') {
          progressError(uploadId, 'Encrypted entries present', 10);
          return NextResponse.json({
            error: 'ZIP contains password-protected entries',
            encryptedEntries: encryptedEntries.map(e => e.name),
            compression, uploadId
          }, { status: 422 });
        }
        if (ENCRYPTED_POLICY === 'attempt' && password) {
          progressUpdate(uploadId, 12, 'decrypting encrypted entries');
          const dec = await extractEncryptedZipBuffer(buf, password, {
            allow: ALLOW, 
            enableVirusScan: ENABLE_SCAN, 
            perFileMaxBytes: PER_FILE_MAX,
            prioritizeHtml: true // Enable HTML prioritization for encrypted files too
          });
          extracted.push(...dec.extracted);
          skipped.push(...dec.skipped);
        } else if (ENCRYPTED_POLICY === 'skip') {
          skipped.push(...encryptedEntries.map(e => ({ path: e.name, reason: 'encrypted' })));
        }
      }

      progressUpdate(uploadId, 15, 'extracting safe entries');
      const safe = await processZipBuffer(buf, {
        allow: ALLOW,
        maxFiles: MAX_FILES,
        maxTotalBytes: MAX_TOTAL,
        maxDepth: MAX_DEPTH,
        perFileMaxBytes: PER_FILE_MAX,
        enableVirusScan: ENABLE_SCAN,
        dedup: true,
        prioritizeHtml: true, // Enable HTML prioritization over text files
        
        onEntry: ({ path, index, total }) => {
          if (index % 5 === 0) progressUpdate(uploadId, Math.min(90, Math.round(15 + (index / Math.max(1, total)) * 70)), `processing: ${path}`);
        },
        onProgress: (pct) => progressUpdate(uploadId, Math.min(95, pct), 'processing')
      });

      extracted.push(...safe.extracted);
      skipped.push(...safe.skipped);

      progressUpdate(uploadId, 97, 'finalizing');
      await sendToLoggingService({
        event: 'zip-complete',
        uploadId, extractedCount: extracted.length, skippedCount: skipped.length, totals: compression
      });

      progressDone(uploadId, { extractedCount: extracted.length, skippedCount: skipped.length });
      return NextResponse.json({
        uploadId, preview, compression,
        files: extracted.map(f => f.fileName),
        extractedFiles: extracted, skipped, totalBytes: safe.totalBytes
      });
    } catch (e) {
      progressError(uploadId, (e as Error).message || 'unknown', 0);
      return NextResponse.json({ error: 'ZIP processing failed', detail: (e as Error).message, uploadId }, { status: 500 });
    }
  }

================================================================================
FILE: app/api/upload-progress/route.ts
================================================================================

  import { NextResponse } from 'next/server';
  import { progressGet } from '@/lib/progressStore';

  export const dynamic = 'force-dynamic';

  export async function GET(req: Request) {
    const { searchParams } = new URL(req.url);
    const id = searchParams.get('id');
    if (!id) return NextResponse.json({ error: 'Missing id' }, { status: 400 });

    const state = progressGet(id);
    if (!state) return NextResponse.json({ status: 'unknown', pct: 0, message: 'Upload not found' }, { status: 200 });

    const response = {
      status: state.status === 'done' ? 'completed' : 
              state.status === 'error' ? 'failed' : 
              state.status === 'running' ? 'processing' : 'uploading',
      pct: state.pct,
      message: state.status === 'done' ? 'Upload completed' :
              state.status === 'error' ? (state as any).error || 'Upload failed' :
              state.status === 'running' ? (state as any).note || 'Processing...' :
              'Uploading...'
    };

    return NextResponse.json(response);
  }

================================================================================
FILE: app/api/creative/save/route.ts
================================================================================

  import { NextRequest, NextResponse } from "next/server";
  import { getPool } from "@/lib/db";
  import { createSubmissionEmail, sendEmail } from "@/lib/emailService";

  function parseFileUrl(u: string) {
    try {
      const m = u.match(/\/api\/files\/([^/]+)\/([^?#]+)/);
      if (m) {
        return {
          id: decodeURIComponent(m[1]),
          name: decodeURIComponent(m[2]),
          file_url: u,
          file_key: `${decodeURIComponent(m[1])}/${decodeURIComponent(m[2])}`,
          original_filename: decodeURIComponent(m[2]),
        };
      }
    } catch {}
    return { file_url: u };
  }

  export const runtime = "nodejs";

  export async function POST(req: NextRequest) {
    try {
      const body = await req.json();

      const {
        affiliateId,
        companyName,
        firstName,
        lastName,
        email: contactEmail,
        telegramId,
        offerId,
        creativeType,
        fromLines,
        subjectLines,
        notes,
        priority = "Moderate",
        files = [],
      } = body || {};

      if (!offerId || !contactEmail || !Array.isArray(files) || files.length === 0) {
        return NextResponse.json(
          { error: "offerId, email and at least one file are required" },
          { status: 400 }
        );
      }

      const pool = getPool();
      const client = await pool.connect();
      let submissionId: number | null = null;

      try {
        await client.query("BEGIN");

        const sub = await client.query(
          `INSERT INTO submissions (
            offer_id, priority, contact_method, contact_info, 
            from_lines, subject_lines, other_request,
            affiliate_id, company_name, telegram_id, creative_type
          ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11) RETURNING id`,
          [
            String(offerId),
            String(priority),
            "email",
            String(contactEmail),
            String(fromLines || ""),
            String(subjectLines || ""),
            String(notes || ""),
            String(affiliateId || ""),
            String(companyName || ""),
            String(telegramId || ""),
            String(creativeType || ""),
          ]
        );

        submissionId = sub.rows[0].id;

        for (const f of files as Array<{ 
          fileName: string; 
          fileUrl: string; 
          fileType?: string; 
          fileSize?: number; 
        }>) {
          const meta = parseFileUrl(f.fileUrl);
          await client.query(
            `INSERT INTO submission_files (
              submission_id, file_url, file_key, original_filename, 
              creative_from_lines, creative_subject_lines, creative_notes, creative_html_code
            ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8)`,
            [
              submissionId,
              meta.file_url ?? null,
              meta.file_key ?? null,
              f.fileName ?? meta.original_filename ?? null,
              fromLines ?? null,
              subjectLines ?? null,
              notes ?? null,
              null,
            ]
          );
        }

        await client.query("COMMIT");
      } catch (e) {
        await client.query("ROLLBACK");
        throw e;
      } finally {
        client.release();
      }

      const contactName = [firstName, lastName].filter(Boolean).join(" ") || "there";
      const trackingLink = `https://www.bigdropsmarketing.com/tracking_link/BDMG${submissionId}`;
      const html = createSubmissionEmail({
        contactName,
        priority: String(priority),
        trackingLink,
      });
      await sendEmail({
        to: contactEmail,
        subject: "Your Submission Has Been Received!",
        html,
      });

      return NextResponse.json({ ok: true, submissionId, trackingLink });
    } catch (e) {
      console.error("save creative error:", e);
      return NextResponse.json({ error: "Failed to save creative" }, { status: 500 });
    }
  }

================================================================================
FILE: app/api/telegram/verify/route.ts
================================================================================

  import { NextRequest, NextResponse } from "next/server";
  import { getPool } from "@/lib/db";

  export async function POST(req: NextRequest) {
    try {
      const { telegramId } = await req.json();

      if (!telegramId) {
        return NextResponse.json({ error: "Missing telegramId" }, { status: 400 });
      }

      const cleanUsername = telegramId.replace(/^@/, "").toLowerCase();

      const pool = getPool();
      const { rows } = await pool.query(
        `SELECT * FROM telegram_users WHERE LOWER(username) = $1 AND chat_id IS NOT NULL LIMIT 1`,
        [cleanUsername]
      );

      if (rows.length > 0) {
        return NextResponse.json({ verified: true, user: rows[0] });
      } else {
        return NextResponse.json({ verified: false });
      }
    } catch (e: unknown) {
      return NextResponse.json({ error: e instanceof Error ? e.message : 'verification error' }, { status: 500 });
    }
  }

================================================================================
FILE: app/api/telegram/poll/route.ts
================================================================================

  import { NextResponse } from 'next/server';
  import { getPool } from '@/lib/db';

  const TOKEN = process.env.TELEGRAM_BOT_TOKEN!;

  async function getOffset() {
    const pool = getPool();
    const { rows } = await pool.query(
      `SELECT value FROM telegram_state WHERE key = 'last_update_id' LIMIT 1`
    );
    return rows[0]?.value ? parseInt(rows[0].value, 10) : undefined;
  }

  async function setOffset(id: number) {
    const pool = getPool();
    await pool.query(
      `INSERT INTO telegram_state(key, value, updated_at)
      VALUES('last_update_id', $1, NOW())
      ON CONFLICT (key) DO UPDATE SET value=$1, updated_at=NOW()`,
      [String(id)]
    );
  }

  async function sendTelegramMessage(chat_id: number, text: string) {
    await fetch(`https://api.telegram.org/bot${TOKEN}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chat_id, text, parse_mode: 'HTML', disable_web_page_preview: true }),
      cache: 'no-store',
    }).catch(() => {});
  }

  export async function POST() {
    try {
      if (!TOKEN) return NextResponse.json({ ok: false, error: 'TELEGRAM_BOT_TOKEN missing' }, { status: 500 });

      const offset = await getOffset();
      const url = new URL(`https://api.telegram.org/bot${TOKEN}/getUpdates`);
      if (offset) url.searchParams.set('offset', String(offset + 1));
      url.searchParams.set('timeout', '0');

      const res = await fetch(url.toString(), { cache: 'no-store' });
      const data = await res.json();

      if (!data.ok) {
        return NextResponse.json({ ok: false, error: 'getUpdates failed', data }, { status: 500 });
      }

      let highestId = offset ?? 0;
      for (const upd of data.result as Array<{ update_id: number; message?: { text?: string; chat?: { id: number; username?: string; first_name?: string } } }>) {
        if (upd.update_id > highestId) highestId = upd.update_id;

        const msg = upd.message;
        if (!msg) continue;

        const text = (msg.text || '').trim().toLowerCase();
        if (!text.startsWith('/start')) continue;

        const chatId = msg.chat?.id;
        const username: string | null = msg.chat?.username || null;
        const firstName: string | null = msg.chat?.first_name || null;
        
        if (!chatId) continue;

        const pool = getPool();
        const client = await pool.connect();
        try {
          await client.query('BEGIN');
          if (username) {
            await client.query(
              `INSERT INTO telegram_users (username, chat_id, first_name, created_at, updated_at)
              VALUES ($1,$2,$3,NOW(),NOW())
              ON CONFLICT (username)
              DO UPDATE SET chat_id=EXCLUDED.chat_id, first_name=EXCLUDED.first_name, updated_at=NOW()`,
              [username, chatId, firstName]
            );
          } else {
            await client.query(
              `INSERT INTO telegram_users (username, chat_id, first_name, created_at, updated_at)
              VALUES ($1,$2,$3,NOW(),NOW())
              ON CONFLICT (username) DO NOTHING`,
              [`chat_${chatId}`, chatId, firstName]
            );
          }
          await client.query('COMMIT');
        } catch (e) {
          await client.query('ROLLBACK');
          throw e;
        } finally {
          client.release();
        }

        await sendTelegramMessage(chatId,
          `✅ Thanks${firstName ? `, <b>${firstName}</b>` : ''}! Your Telegram is now linked.\n\nReturn to the form and click <b>Verify</b>.`
        );
      }

      if (highestId) await setOffset(highestId);
      return NextResponse.json({ ok: true, processed: data.result?.length || 0, last_update_id: highestId });
    } catch (e: unknown) {
      return NextResponse.json({ ok: false, error: e instanceof Error ? e.message : 'poll error' }, { status: 500 });
    }
  }

================================================================================
FILE: app/api/everflow/offers/route.ts
================================================================================

  import { NextResponse } from 'next/server';

  export async function GET() {
    const EVERFLOW_API_KEY = process.env.EVERFLOW_API_KEY;
    if (!EVERFLOW_API_KEY) {
      return NextResponse.json({ error: 'Everflow API key is not configured.' }, { status: 500 });
    }

    try {
      try {
        const runnableResponse = await fetch('https://api.eflow.team/v1/affiliates/offersrunnable', {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'X-Eflow-API-Key': EVERFLOW_API_KEY,
            'User-Agent':
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
          },
          cache: 'no-store',
        });

        if (runnableResponse.ok) {
          const runnableData = await runnableResponse.json();
          if (runnableData.offers?.length) {
            const offerIds = runnableData.offers
              .map((o: { network_offer_id: string | number }) => o.network_offer_id.toString())
              .sort((a: string, b: string) => parseInt(a, 10) - parseInt(b, 10));
            return NextResponse.json(offerIds);
          }
        }
      } catch {}

      try {
        const allOffersResponse = await fetch('https://api.eflow.team/v1/affiliates/alloffers', {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'X-Eflow-API-Key': EVERFLOW_API_KEY,
            'User-Agent':
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
          },
          cache: 'no-store',
        });

        if (allOffersResponse.ok) {
          const allOffersData = await allOffersResponse.json();
          if (allOffersData.offers?.length) {
            const offerIds = allOffersData.offers
              .map((o: { network_offer_id: string | number }) => o.network_offer_id.toString())
              .sort((a: string, b: string) => parseInt(a, 10) - parseInt(b, 10));
            return NextResponse.json(offerIds);
          }
        }
      } catch {}

      try {
        const networkResponse = await fetch(
          'https://api.eflow.team/v1/networks/offerstable?page=1&page_size=1000',
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Eflow-API-Key': EVERFLOW_API_KEY,
              'User-Agent':
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
            },
            body: JSON.stringify({
              filters: { offer_status: 'active' },
              sort_by: { column: 'created', order: 'desc' },
            }),
            cache: 'no-store',
          }
        );

        if (networkResponse.ok) {
          const networkData = await networkResponse.json();
          const offers = networkData.offers || networkData.entries || [];
          if (offers.length) {
            const allOfferIds = offers.map(
              (o: { network_offer_id: string | number }) => o.network_offer_id.toString()
            );
            const unique = Array.from(new Set(allOfferIds)).sort(
              (a, b) => parseInt(a as string, 10) - parseInt(b as string, 10)
            );
            return NextResponse.json(unique);
          }
        }
      } catch {}

      return NextResponse.json([]);
    } catch {
      return NextResponse.json({ error: 'An internal server error occurred.' }, { status: 500 });
    }
  }

================================================================================
FILE: app/api/analyze-zip/route.ts
================================================================================

  import { NextResponse } from "next/server";
  import JSZip from "jszip";
  import crypto from "crypto";
  import path from "path";
  import fs from "fs/promises";
  import sharp from "sharp";
  import { getFilePath } from "@/lib/fileStorage";
  import { Constants } from "@/app/Constants/Constants";
  import { JSDOM } from "jsdom";

  type AnalyzedItem = {
    id: string;
    name: string;           
    type: "image" | "html" | "other";
    size: number;
    url: string;            
    previewUrl?: string;    
    html?: boolean;
    embeddedHtml?: string;  
    entryFile?: string;     
    assets?: string[];      
  };

  type UploadAnalysis = {
    uploadId: string;
    isSingleCreative: boolean;
    items: AnalyzedItem[];
    counts: { images: number; htmls: number; others: number; total: number };
    summary: {
      totalSize: number;
      processingTime: number;
      warnings: string[];
      errors: string[];
    };
  };

  export const dynamic = "force-dynamic";

  const ZIP_CONFIG = Constants.zipProcessing;
  const MAX_DEPTH = ZIP_CONFIG.MAX_ZIP_DEPTH;
  const MAX_ZIP_SIZE = ZIP_CONFIG.MAX_ZIP_SIZE;
  const LARGE_ZIP_WARNING_THRESHOLD = ZIP_CONFIG.LARGE_ZIP_WARNING_THRESHOLD;
  const MAX_FILES_PER_ZIP = ZIP_CONFIG.MAX_FILES_PER_ZIP;

  // Enhanced path normalization with ZipSlip protection
  const norm = (p: string) => {
    const n = p.replace(/\\/g, "/").replace(/^\/+/, "").replace(/\/+/g, "/");
    if (n.includes("..")) {
      throw new Error(`Unsafe path detected: ${p}`);
    }
    return n;
  };

  // Case-insensitive normalization for consistent claiming
  const lc = (p: string) => norm(p).toLowerCase();

  // Noise file detection
  const isNoise = (p: string) => p.startsWith("__MACOSX/") || /(^|\/)\.DS_Store$/i.test(p);

  // File type detection helpers
  const isHtml = (p: string) => /\.html?$/i.test(p);
  const isText = (p: string) => /\.txt$/i.test(p);
  const isImage = (p: string) => /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(p);

  // Helper to get parent directory
  function parentDir(p: string) { 
    const a = norm(p).split("/"); 
    a.pop(); 
    return a.join("/"); 
  }

  // Helper to resolve relative paths
  function resolveRelative(baseHtmlPath: string, ref: string) {
    if (/^(data:|https?:|mailto:|javascript:)/i.test(ref)) return null;
    const base = parentDir(baseHtmlPath);
    return norm(`${base}/${ref}`);
  }

  const isImg = (n: string) => ZIP_CONFIG.IMAGE_EXTENSIONS.some(ext => n.toLowerCase().endsWith(ext));
  const isZip = (n: string) => /\.zip$/i.test(n);
  const isAllowedFile = (n: string) => ZIP_CONFIG.ALLOWED_EXTENSIONS.some(ext => n.toLowerCase().endsWith(ext));


  type WorkItem = { 
    data: ArrayBuffer; 
    basePath: string; 
    depth: number; 
    zip: JSZip;
  };

  type ZipEntryLite = { 
    path: string; 
    dir: boolean; 
    size: number; 
    getData?: () => Promise<ArrayBuffer>;
    originalEntry?: any;
  };


  function getTopLevelGroupKey(fullPath: string): string {
    const parts = norm(fullPath).split("/");
    if (parts.length > 1) {
      return parts[0]; 
    }
    const filename = parts[0];
    return filename.replace(/\.[^.]+$/, "");
  }

  // Case-insensitive file matching helper with bulletproof normalization
  function buildLowerIndex<T extends { path: string; isDir?: boolean }>(files: T[]) {
    const map = new Map<string, T>();
    for (const f of files) {
      if (!f.isDir && !isNoise(f.path)) {
        map.set(lc(f.path), f);
      }
    }
    return (query: string): T | null => {
      return map.get(lc(query)) || null;
    };
  }

  // Enhanced security sanitization
  function stripScriptsAndHandlers(html: string): string {
    // Remove <script> tags
    html = html.replace(/<script[\s\S]*?<\/script>/gi, "");
    // Remove inline event handlers (onclick, onload, etc.)
    html = html.replace(/\son\w+\s*=\s*(['"]).*?\1/gi, "");
    // Remove javascript: URLs
    html = html.replace(/javascript:\s*[^"'\s>]+/gi, "#");
    // Remove data: URLs that might contain scripts
    html = html.replace(/data:\s*text\/html[^"'\s>]*/gi, "#");
    return html;
  }

  async function writeFile(uploadId: string, relPath: string, data: Buffer) {
    const abs = await getFilePath(uploadId, relPath);
    await fs.mkdir(path.dirname(abs), { recursive: true });
    await fs.writeFile(abs, data);
    return abs;
  }

  async function makeThumbIfImage(uploadId: string, rel: string, data: Buffer) {
    if (!isImg(rel)) return undefined;
    const thumbRel = `thumbs/${rel.replace(/\//g, "__")}.jpg`;
    try {
      const thumb = await sharp(data)
        .resize(480, 480, { fit: "inside", withoutEnlargement: true })
        .jpeg({ quality: 80 })
        .toBuffer();
      await writeFile(uploadId, thumbRel, thumb);
      return thumbRel;
    } catch {
      return undefined;
    }
  }

  // Enhanced asset embedding with comprehensive srcset and CSS URL handling
  async function embedAssetsInHtml(
    htmlContent: string, 
    htmlPath: string, 
    effectiveFiles: ZipEntryLite[],
    claimed: Set<string>
  ): Promise<string> {
    try {
      const dom = new JSDOM(htmlContent);
      const document = dom.window.document;
      
      // Create case-insensitive matcher for files
      const findFile = createCaseInsensitiveMatcher(effectiveFiles);
      
      // Track embedded size for performance limits
      let totalEmbeddedSize = 0;
      
      // Helper to convert asset to data URL with size limits and claiming
      const toDataURL = async (refPath: string): Promise<string> => {
        const resolved = resolveRelative(htmlPath, refPath);
        if (!resolved) return refPath;
        
        const file = findFile(resolved);
        if (!file || !file.getData) {
          return refPath; // Return original if not found
        }
        
        // BULLETPROOF CLAIMING: Always mark as claimed for any asset reference
        claimed.add(lc(file.path));
        
        // Check individual asset size limit
        if (file.size > MAX_ASSET_SIZE) {
          console.warn(`Asset too large to embed: ${refPath} (${file.size} bytes)`);
          return refPath;
        }
        
        // Check total embedded size limit
        if (totalEmbeddedSize + file.size > MAX_EMBEDDED_SIZE_PER_CREATIVE) {
          console.warn(`Total embedded size limit reached for creative`);
          return refPath;
        }
        
        try {
          const assetData = await file.getData();
          const mime = getMimeType(file.path);
          const b64 = Buffer.from(assetData).toString("base64");
          totalEmbeddedSize += file.size;
          return `data:${mime};base64,${b64}`;
        } catch (error) {
          console.warn(`Failed to convert asset to data URL: ${refPath}`, error);
          return refPath;
        }
      };
      
      // Process img src attributes
      const images = document.querySelectorAll('img[src]');
      for (const img of images) {
        const src = img.getAttribute('src');
        if (src && !src.startsWith('data:') && !src.startsWith('http')) {
          try {
            const dataUrl = await toDataURL(src);
            img.setAttribute('src', dataUrl);
          } catch (error) {
            console.warn(`Failed to embed img src: ${src}`, error);
          }
        }
      }
      
      // Process img srcset attributes
      const imagesWithSrcset = document.querySelectorAll('img[srcset]');
      for (const img of imagesWithSrcset) {
        const srcset = img.getAttribute('srcset');
        if (srcset && !srcset.includes('data:')) {
          try {
            const parts = srcset.split(',').map(s => s.trim());
            const processedParts = await Promise.all(parts.map(async part => {
              const [url, descriptor] = part.split(/\s+/);
              const dataUrl = await toDataURL(url);
              return descriptor ? `${dataUrl} ${descriptor}` : dataUrl;
            }));
            img.setAttribute('srcset', processedParts.join(', '));
          } catch (error) {
            console.warn(`Failed to embed img srcset: ${srcset}`, error);
          }
        }
      }
      
      // Process CSS background-image URLs in inline styles
      const elementsWithBg = document.querySelectorAll('*');
      for (const element of elementsWithBg) {
        const style = element.getAttribute('style');
        if (style && style.includes('background-image')) {
          try {
            let newStyle = style;
            const urlMatches = style.match(/url\((['"]?)([^'")]+)\1\)/gi);
            if (urlMatches) {
              for (const match of urlMatches) {
                const urlMatch = match.match(/url\((['"]?)([^'")]+)\1\)/i);
                if (urlMatch) {
                  const [fullMatch, quote, url] = urlMatch;
                  const dataUrl = await toDataURL(url);
                  newStyle = newStyle.replace(fullMatch, `url(${quote}${dataUrl}${quote})`);
                }
              }
            }
            element.setAttribute('style', newStyle);
          } catch (error) {
            console.warn(`Failed to embed background image: ${style}`, error);
          }
        }
      }
      
      // Process linked CSS files
      const linkElements = document.querySelectorAll('link[rel="stylesheet"][href]');
      for (const link of linkElements) {
        const href = link.getAttribute('href');
        if (href && !href.startsWith('data:') && !href.startsWith('http')) {
          try {
            const resolved = resolveRelative(htmlPath, href);
            const cssFile = resolved ? findFile(resolved) : null;
            if (cssFile && cssFile.getData) {
              // Mark CSS file as claimed
              claimed.add(lc(cssFile.path));
              
              const cssContent = new TextDecoder("utf-8", { fatal: false }).decode(
                Buffer.from(await cssFile.getData())
              );
              
              // Process CSS URLs
              let processedCSS = cssContent;
              const cssUrlMatches = cssContent.match(/url\((['"]?)([^'")]+)\1\)/gi);
              if (cssUrlMatches) {
                for (const match of cssUrlMatches) {
                  const urlMatch = match.match(/url\((['"]?)([^'")]+)\1\)/i);
                  if (urlMatch) {
                    const [fullMatch, quote, url] = urlMatch;
                    const dataUrl = await toDataURL(url);
                    processedCSS = processedCSS.replace(fullMatch, `url(${quote}${dataUrl}${quote})`);
                  }
                }
              }
              
              // Replace link with inline style
              const styleElement = document.createElement('style');
              styleElement.textContent = processedCSS;
              link.parentNode?.replaceChild(styleElement, link);
            }
          } catch (error) {
            console.warn(`Failed to process linked CSS: ${href}`, error);
          }
        }
      }
      
      // Process inline <style> blocks
      const styleElements = document.querySelectorAll('style');
      for (const style of styleElements) {
        try {
          const cssContent = style.textContent || '';
          let processedCSS = cssContent;
          const inlineUrlMatches = cssContent.match(/url\((['"]?)([^'")]+)\1\)/gi);
          if (inlineUrlMatches) {
            for (const match of inlineUrlMatches) {
              const urlMatch = match.match(/url\((['"]?)([^'")]+)\1\)/i);
              if (urlMatch) {
                const [fullMatch, quote, url] = urlMatch;
                const dataUrl = await toDataURL(url);
                processedCSS = processedCSS.replace(fullMatch, `url(${quote}${dataUrl}${quote})`);
              }
            }
          }
          style.textContent = processedCSS;
        } catch (error) {
          console.warn('Failed to process inline CSS', error);
        }
      }
      
      return dom.serialize();
    } catch (error) {
      console.warn('Failed to embed assets in HTML:', error);
      return htmlContent; // Return original if embedding fails
    }
  }

  function getMimeType(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes: { [key: string]: string } = {
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.png': 'image/png',
      '.gif': 'image/gif',
      '.webp': 'image/webp',
      '.bmp': 'image/bmp',
      '.svg': 'image/svg+xml',
      '.ico': 'image/x-icon',
      '.css': 'text/css',
      '.js': 'application/javascript',
      '.txt': 'text/plain',
      '.html': 'text/html',
      '.htm': 'text/html',
      '.woff': 'font/woff',
      '.woff2': 'font/woff2',
      '.ttf': 'font/ttf',
      '.eot': 'application/vnd.ms-fontobject'
    };
    return mimeTypes[ext] || 'application/octet-stream';
  }

  // Performance limits for asset embedding
  const MAX_EMBEDDED_SIZE_PER_CREATIVE = 10 * 1024 * 1024; // 10MB
  const MAX_ASSET_SIZE = 2 * 1024 * 1024; // 2MB per asset

  function findHtmlEntryFile(htmlFiles: string[]): string | null {
    if (htmlFiles.length === 0) return null;
    if (htmlFiles.length === 1) return htmlFiles[0];
    
    for (const preference of ZIP_CONFIG.HTML_ENTRY_PREFERENCES) {
      const found = htmlFiles.find(file => 
        normalize(file).endsWith(normalize(preference))
      );
      if (found) return found;
    }
    
    return htmlFiles[0];
  }


  // Enhanced nested ZIP analysis with breadth-first expansion
  async function analyzeNestedZipContents(
    rootZipBuffer: ArrayBuffer,
    uploadId: string
  ): Promise<{ items: AnalyzedItem[]; warnings: string[] }> {
    const baseUrl = `/api/files/${encodeURIComponent(uploadId)}/`;
    const queue: WorkItem[] = [];
    const allEntries: ZipEntryLite[] = [];
    let totalFiles = 0;
    let totalSize = 0;
    const warnings: string[] = [];

    try {
      const rootZip = await JSZip.loadAsync(rootZipBuffer, { createFolders: false });
      queue.push({ 
        data: rootZipBuffer, 
        basePath: "", 
        depth: 0, 
        zip: rootZip 
      });
    } catch (error) {
      throw new Error(`Invalid ZIP file format: ${error instanceof Error ? error.message : String(error)}`);
    }

    while (queue.length > 0) {
      const { data, basePath, depth, zip } = queue.shift()!;
      
      if (depth > MAX_DEPTH) {
        warnings.push(`Skipping nested ZIP at depth ${depth} (max: ${MAX_DEPTH})`);
        continue;
      }

    const entries = Object.values(zip.files);

    for (const entry of entries) {
      if (entry.dir) continue;

      try {
        const rel0 = safeNormalize(entry.name);
        const rel = safeNormalize(basePath ? `${basePath}/${rel0}` : rel0);
        
        // Skip noise files
        if (isNoise(rel)) continue;
        
        if (!isAllowedFile(rel)) continue;
        
        if (totalFiles >= MAX_FILES_PER_ZIP) {
          throw new Error(`ZIP contains too many files (max: ${MAX_FILES_PER_ZIP})`);
        }
        
        try {
          const data = await entry.async("arraybuffer");
          const size = data.byteLength;
          totalSize += size;
          
          if (totalSize > MAX_ZIP_SIZE) {
            throw new Error(`ZIP size exceeds maximum allowed size of ${MAX_ZIP_SIZE} bytes`);
          }
          
          if (isZip(rel) && depth < MAX_DEPTH) {
            try {
              const nestedZip = await JSZip.loadAsync(data, { createFolders: false });
              const nestedBasePath = rel.replace(/\.zip$/i, "");
              queue.push({ 
                data, 
                basePath: nestedBasePath, 
                depth: depth + 1, 
                zip: nestedZip 
              });
              continue;
            } catch (error) {
              warnings.push(`Failed to process nested ZIP: ${rel}`);
              continue;
            }
          }
          
          allEntries.push({
            path: rel,
            dir: false,
            size,
            getData: async () => data,
            originalEntry: entry
          });
          
          totalFiles++;
        } catch (error) {
          console.warn(`Failed to process file: ${rel}`, error);
        }
      } catch (error) {
        console.warn(`Failed to normalize path: ${entry.name}`, error);
      }
    }
    }

    // Group entries into creatives with enhanced path handling
    const groups = new Map<string, ZipEntryLite[]>();
    for (const entry of allEntries) {
      if (entry.dir) continue;
      try {
        const key = getTopLevelGroupKey(entry.path);
        if (!groups.has(key)) {
          groups.set(key, []);
        }
        groups.get(key)!.push(entry);
      } catch (error) {
        console.warn(`Failed to group entry: ${entry.path}`, error);
      }
    }

    const analyzedItems: AnalyzedItem[] = [];
    const claimed = new Set<string>(); // Track claimed assets globally
    
    for (const [groupKey, entries] of groups) {
      const files = entries.filter(e => !e.dir);
      if (!files.length) continue;

      const htmls = files.filter(f => isHtml(f.path));
      const images = files.filter(f => isImg(f.path));
      const texts = files.filter(f => isText(f.path));
      const others = files.filter(f => !isHtml(f.path) && !isImg(f.path) && !isText(f.path));

      // Ignore .txt files when HTML exists (per creative)
      const effectiveFiles = htmls.length > 0 
        ? files.filter(f => !isText(f.path)) 
        : files;

      let entryFile: ZipEntryLite | undefined;
      let creativeType: "image" | "html" | "other";
      
      if (htmls.length > 0) {
        const htmlPaths = htmls.map(h => h.path);
        const preferredHtml = findHtmlEntryFile(htmlPaths);
        entryFile = htmls.find(h => h.path === preferredHtml) || htmls[0];
        creativeType = "html";
      } else if (images.length > 0) {
        entryFile = images[0];
        creativeType = "image";
      } else {
        entryFile = effectiveFiles[0];
        creativeType = "other";
      }

      if (!entryFile) continue;

      let totalCreativeSize = 0;
      for (const file of effectiveFiles) {
        totalCreativeSize += file.size;
        if (file.getData) {
          const data = Buffer.from(await file.getData());
          await writeFile(uploadId, file.path, data);
        }
      }

      const item: AnalyzedItem = {
        id: uploadId,
        name: entryFile.path,
        type: creativeType,
        size: totalCreativeSize,
        url: baseUrl + entryFile.path,
        html: creativeType === "html",
        entryFile: entryFile.path,
        assets: effectiveFiles
          .filter(f => f !== entryFile)
          .map(f => f.path)
      };

      if (creativeType === "image" && entryFile.getData) {
        try {
          const data = Buffer.from(await entryFile.getData());
          const thumbRel = await makeThumbIfImage(uploadId, entryFile.path, data);
        item.previewUrl = thumbRel ? baseUrl + thumbRel : item.url;
        } catch (error) {
          console.warn(`Failed to generate thumbnail for ${entryFile.path}:`, error);
        }
      }

      if (creativeType === "html" && entryFile.getData) {
        try {
          const htmlBuffer = await entryFile.getData();
          let htmlContent = new TextDecoder("utf-8", { fatal: false }).decode(htmlBuffer);
          
          htmlContent = stripScriptsAndHandlers(htmlContent);
          
          const embeddedHtml = await embedAssetsInHtml(htmlContent, entryFile.path, effectiveFiles, claimed);
          item.embeddedHtml = embeddedHtml;
        } catch (error) {
          console.warn(`Failed to embed assets for ${groupKey}:`, error);
          warnings.push(`Failed to embed assets for ${groupKey}: ${error instanceof Error ? error.message : String(error)}`);
        }
      }

      analyzedItems.push(item);
    }

    // Add unclaimed images as standalone creatives
    for (const entry of allEntries) {
      if (entry.dir) continue;
      
      const normalizedPath = lc(entry.path);
      if (isImg(entry.path) && !claimed.has(normalizedPath)) {
        const item: AnalyzedItem = {
          id: uploadId,
          name: entry.path,
          type: "image",
          size: entry.size,
          url: baseUrl + entry.path,
          previewUrl: baseUrl + entry.path
        };

        // Generate thumbnail if possible
        if (entry.getData) {
          try {
            const data = Buffer.from(await entry.getData());
            const thumbRel = await makeThumbIfImage(uploadId, entry.path, data);
            if (thumbRel) {
              item.previewUrl = baseUrl + thumbRel;
            }
          } catch (error) {
            console.warn(`Failed to generate thumbnail for unclaimed image ${entry.path}:`, error);
          }
        }

        analyzedItems.push(item);
      }
    }

    return { items: analyzedItems, warnings };
  }



  export async function POST(req: Request) {
    const startTime = Date.now();
    const warnings: string[] = [];
    const errors: string[] = [];
    
    try {
      const formData = await req.formData();
      const file = formData.get("file");
      
      if (!file || !(file instanceof Blob)) {
        return NextResponse.json({ error: "ZIP file is required" }, { status: 400 });
      }

      const fileType = file.type;
      if (!ZIP_CONFIG.ALLOWED_ZIP_TYPES.includes(fileType) && fileType !== '') {
        warnings.push(`Unexpected file type: ${fileType}. Proceeding with analysis.`);
      }

      const fileSize = file.size;
      if (fileSize > MAX_ZIP_SIZE) {
        return NextResponse.json(
          { error: `File size (${fileSize} bytes) exceeds maximum allowed size (${MAX_ZIP_SIZE} bytes)` },
          { status: 400 }
        );
      }

      // Add warning for large but acceptable ZIP files
      if (fileSize > LARGE_ZIP_WARNING_THRESHOLD) {
        warnings.push(`Large ZIP file detected (${Math.round(fileSize / 1024 / 1024)}MB). Processing may take longer and previews might be slower.`);
      }

      const uploadId = crypto.randomUUID();
      const fileBuffer = await file.arrayBuffer();
      
      const { items: allItems, warnings: analysisWarnings } = await analyzeNestedZipContents(fileBuffer, uploadId);
      warnings.push(...analysisWarnings);

      if (allItems.length === 0) {
        return NextResponse.json(
          { error: "No valid creatives found in ZIP file" },
          { status: 400 }
        );
      }

      const images = allItems.filter(i => i.type === "image").length;
      const htmls = allItems.filter(i => i.type === "html").length;
      const others = allItems.filter(i => i.type === "other").length;
      const totalSize = allItems.reduce((sum, item) => sum + item.size, 0);

      const isSingleCreative = allItems.length === 1;

      if (htmls > 0 && images > 0) {
        warnings.push("ZIP contains both HTML and image creatives. HTML creatives will be prioritized.");
      }
      
      if (others > 0) {
        warnings.push(`${others} non-creative files were found and included.`);
      }

      const processingTime = Date.now() - startTime;

      const analysis: UploadAnalysis = {
        uploadId,
        isSingleCreative,
        items: allItems,
        counts: { images, htmls, others, total: allItems.length },
        summary: {
          totalSize,
          processingTime,
          warnings,
          errors
        }
      };

      return NextResponse.json(analysis, { status: 200 });
      
    } catch (error) {
      const processingTime = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : String(error);
      
      console.error('ZIP analysis failed:', error);
      
      return NextResponse.json(
        { 
          error: "ZIP analysis failed", 
          detail: errorMessage,
          summary: {
            totalSize: 0,
            processingTime,
            warnings,
            errors: [...errors, errorMessage]
          }
        },
        { status: 500 }
      );
    }
  }

================================================================================
FILE: app/api/check-telegram-start/route.ts
================================================================================

  import { NextRequest, NextResponse } from 'next/server'
  import { getPool } from '@/lib/db'

  export async function POST(req: NextRequest) {
    try {
      const { username } = await req.json();
      if (!username) {
        return NextResponse.json({ started: false, message: 'username required' }, { status: 400 });
      }

      const clean = String(username).replace(/^@/, '').trim();

      const pool = getPool();
      const { rows } = await pool.query(
        `SELECT username, chat_id, first_name
        FROM telegram_users
        WHERE LOWER(username) = LOWER($1)
        LIMIT 1`,
        [clean]
      );

      if (rows.length) {
        return NextResponse.json({ started: true, user: rows[0] });
      }

      return NextResponse.json({ started: false, message: 'not_found' });
    } catch (e: unknown) {
      return NextResponse.json({ started: false, message: e instanceof Error ? e.message : 'error' }, { status: 500 });
    }
  }

================================================================================
FILE: app/api/creative/delete/route.ts
================================================================================

  import { NextRequest, NextResponse } from "next/server";

  export const runtime = "nodejs";

  export async function POST(req: NextRequest) {
    try {
      const { fileUrl, creativeId, previewUrl, relatedIds = [] } = await req.json() as {
        fileUrl?: string; 
        creativeId?: string; 
        previewUrl?: string; 
        relatedIds?: string[]
      };

      const ids = new Set<string>();
      if (creativeId) ids.add(creativeId);
      if (fileUrl) {
        const m = fileUrl.match(/\/api\/files\/([^/]+)\//) || fileUrl.match(/[?&]id=([^&]+)/);
        if (m) ids.add(decodeURIComponent(m[1]));
      }
      if (previewUrl) {
        const m = previewUrl.match(/\/api\/files\/([^/]+)\//) || previewUrl.match(/[?&]id=([^&]+)/);
        if (m) ids.add(decodeURIComponent(m[1]));
      }
      for (const x of relatedIds) if (x) ids.add(x);

      const res = await fetch(`${process.env.NEXT_PUBLIC_BASE_PATH || ''}/api/files/bulk-delete`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ids: Array.from(ids) }),
      });

      const out = await res.json();
      return NextResponse.json(out, { status: res.status });
    } catch (e) {
      console.error("delete creative error:", e);
          return NextResponse.json({ error: "Failed to delete creative" }, { status: 500 });
  }
}

================================================================================
FILE: components/modals/FileUploadModal.tsx
================================================================================

  "use client";

  import React from "react";
  import { Button } from "@/components/ui/button";
  import {
    X,
    Upload,
    CheckCircle,
    AlertCircle,
    FolderOpen,
    FileText,
    Image,
    PencilLine,
  } from "lucide-react";
  import { useFileUpload } from "@/hooks";
  import { API_ENDPOINTS } from "@/constants/apiEndpoints";
  import { FILE_UPLOAD_CONFIG, formatFileSize } from "@/constants";
  import { UploadAnalysis, AnalyzedItem } from "@/types/upload";

  export type UploadType = "single" | "multiple";

  type UploadProvider = "local" | "vercel-blob" | "s3";
  type ChunkingConfig = { enabled: boolean; chunkSize: number }; // bytes

  interface FileUploadModalProps {
    isOpen: boolean;
    onClose: () => void;
    uploadType: UploadType;
    onFileUpload: (file: File) => void | Promise<void> | Promise<{ uploadId?: string }>;
    onZipAnalyzed?: (analysis: UploadAnalysis, file: File) => void;
    creativeType?: string; // Add creativeType prop

    uploadEndpoint?: string;
    uploadZipEndpoint?: string;
    authHeaders?: Record<string, string>;
    userContext?: { userId?: string; role?: string };

    onUploadProgress?: (pct: number) => void;
    onUploadError?: (error: Error) => void;

    onServerValidate?: (file: File) => Promise<{ ok: boolean; reason?: string }>;

    retry?: { retries: number; baseDelayMs: number };
    chunking?: ChunkingConfig;
    provider?: UploadProvider;
    compressImages?: boolean;
    metadata?: Record<string, string | number | boolean>;
    enableVirusScan?: boolean;
    onPreviewGenerated?: (url: string) => void;
    onFromSubjectLinesSave?: (fromLines: string, subjectLines: string) => void;
  }

  const FileUploadModal: React.FC<FileUploadModalProps> = ({
    isOpen,
    onClose,
    uploadType,
    onFileUpload,
    onZipAnalyzed,
    creativeType,
    onFromSubjectLinesSave,
  }) => {
    const config =
      uploadType === "single"
        ? FILE_UPLOAD_CONFIG.SINGLE_CREATIVE
        : FILE_UPLOAD_CONFIG.MULTIPLE_CREATIVES;

    const [zipAnalysis, setZipAnalysis] = React.useState<UploadAnalysis | null>(
      null
    );
    const [isAnalyzing, setIsAnalyzing] = React.useState(false);
    const [isFromSubjectLinesModalOpen, setIsFromSubjectLinesModalOpen] = React.useState(false);
    const [uploadStatus, setUploadStatus] = React.useState<'idle' | 'uploading' | 'success' | 'error'>('idle');

    const { state, handlers, startUpload } = useFileUpload(
      config.ALLOWED_TYPES,
      config.MAX_SIZE_MB,
      async (file: File) => {
        if (file.name.toLowerCase().endsWith(".zip") && onZipAnalyzed) {
          setIsAnalyzing(true);
          try {
            const analysis = await analyzeZipFile(file);
            setZipAnalysis(analysis);
            onZipAnalyzed(analysis, file);
            return;
          } catch (error) {
            console.error("ZIP analysis failed:", error);
          } finally {
            setIsAnalyzing(false);
          }
        }

        // Start upload tracking
        setUploadStatus('uploading');
        
        try {
          // Call the onFileUpload callback
          await onFileUpload(file);
          setUploadStatus('success');
          // Close modal after a short delay to show completion
          setTimeout(() => {
            handlers.resetState();
            onClose();
          }, 1000);
        } catch (error) {
          setUploadStatus('error');
          console.error('Upload failed:', error);
        }
      }
    );

    // Reset status when modal opens/closes
    React.useEffect(() => {
      if (isOpen) {
        setUploadStatus('idle');
      }
    }, [isOpen]);

    const analyzeZipFile = async (file: File): Promise<UploadAnalysis> => {
      const formData = new FormData();
      formData.append("file", file);

      const response = await fetch(API_ENDPOINTS.ANALYZE_ZIP, {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        throw new Error("ZIP analysis failed");
      }

      return response.json();
    };

    React.useEffect(() => {
      if (isOpen) {
        // Store current scroll position
        const scrollY = window.scrollY;
        document.body.style.position = "fixed";
        document.body.style.top = `-${scrollY}px`;
        document.body.style.width = "100%";
        document.body.style.overflow = "hidden";
      } else {
        // Restore scroll position and body styles
        const scrollY = document.body.style.top;
        document.body.style.position = "";
        document.body.style.top = "";
        document.body.style.width = "";
        document.body.style.overflow = "";
        if (scrollY) {
          window.scrollTo(0, parseInt(scrollY || "0") * -1);
        }
      }

      // Cleanup function to restore scrolling when component unmounts
      return () => {
        const scrollY = document.body.style.top;
        document.body.style.position = "";
        document.body.style.top = "";
        document.body.style.width = "";
        document.body.style.overflow = "";
        if (scrollY) {
          window.scrollTo(0, parseInt(scrollY || "0") * -1);
        }
      };
    }, [isOpen]);

    React.useEffect(() => {
      if (isOpen) {
        const timer = setTimeout(() => {
          handlers.resetState();
        }, 0);
        return () => clearTimeout(timer);
      }
    }, [isOpen, handlers]);

    const handleClose = () => {
      handlers.resetState();
      onClose();
    };

    const getModalTitle = () => {
      return uploadType === "single"
        ? "Upload Single Creative"
        : "Upload Multiple Creatives";
    };

    const getDragDropContent = () => {
      if (uploadStatus === "success") {
        return (
          <div className="space-y-3">
            <CheckCircle className="h-12 w-12 text-green-500 mx-auto" />
            <div>
              <p className="text-sm font-medium text-green-900">
                Upload Successful!
              </p>
              <p className="text-xs text-green-600">File uploaded successfully</p>
            </div>
          </div>
        );
      }

      if (state.selectedFile) {
        return (
          <div className="space-y-3">
            <CheckCircle className="h-12 w-12 text-blue-500 mx-auto" />
            <div>
              <p className="text-sm font-medium text-gray-900">
                {state.selectedFile.name}
              </p>
              <p className="text-xs text-gray-500">
                {formatFileSize(state.selectedFile.size)}
              </p>
              {uploadType === "multiple" && (
                <p className="text-xs text-blue-600 font-medium">
                  ZIP file ready for upload
                </p>
              )}
            </div>
          </div>
        );
      }

      return (
        <div className="space-y-3">
          <Upload className={`h-12 w-12 text-gray-400 mx-auto`} />
          <div>
            <p className="text-sm font-medium text-gray-900">
              {config.PLACEHOLDER}
            </p>
            <p className="text-xs text-gray-500">or click to browse</p>
          </div>
        </div>
      );
    };

    const getInfoBox = () => {
      if (uploadType === "multiple") {
        return (
          <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
            <div className="flex items-start gap-2">
              <FolderOpen className="h-4 w-4 text-blue-500 mt-0.5" />
              <div className="text-sm text-blue-700">
                <p className="font-medium">ZIP File Requirements:</p>
                <ul className="mt-1 space-y-1 text-xs">
                  {config.REQUIREMENTS?.map((req: string, index: number) => (
                    <li key={index}>• {req}</li>
                  ))}
                </ul>
              </div>
            </div>
          </div>
        );
      }
      return null;
    };

    const getFileInfo = () => {
      if (!state.selectedFile) return null;

      return (
        <div className="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
          <div className="flex items-center gap-2">
            <Upload className="h-4 w-4 text-gray-400" />
            <div className="flex-1 min-w-0">
              <p className="text-sm font-medium text-blue-900 truncate">
                {state.selectedFile.name}
              </p>
              <p className="text-xs text-blue-700">
                {formatFileSize(state.selectedFile.size)}
              </p>
            </div>
          </div>
        </div>
      );
    };

    if (!isOpen) return null;

    return (
      <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4">
        <div className="bg-white rounded-lg shadow-xl w-full max-w-md">
          {/* Header */}
          <div className="flex items-center justify-between p-6 border-b border-color-border">
            <h2 className="text-xl font-semibold text-gray-900">
              {getModalTitle()}
            </h2>
            <Button
              variant="ghost"
              size="sm"
              onClick={handleClose}
              className="h-8 w-8 p-0 hover:bg-red-500"
            >
              <X className="h-4 w-4" />
            </Button>
          </div>

          {/* Content */}
          <div className="p-6">
            {/* Show only progress when uploading */}
            {uploadStatus === "uploading" && (
              <div className="text-center space-y-6">
                <div className="space-y-3">
                  <div className="animate-spin rounded-full h-16 w-16 border-4 border-blue-200 border-t-blue-600 mx-auto"></div>
                  <div>
                    <h3 className="text-lg font-medium text-gray-900">Uploading File</h3>
                    <p className="text-sm text-gray-500">{state.selectedFile?.name}</p>
                  </div>
                </div>
                
                <p className="text-xs text-gray-500">
                  Please wait while your file is being uploaded...
                </p>
              </div>
            )}

            {/* Show success state when complete */}
            {uploadStatus === "success" && (
              <div className="text-center space-y-6">
                <div className="space-y-3">
                  <CheckCircle className="h-16 w-16 text-green-500 mx-auto" />
                  <div>
                    <h3 className="text-lg font-medium text-green-900">Upload Complete!</h3>
                    <p className="text-sm text-green-600">{state.selectedFile?.name}</p>
                  </div>
                </div>
                
                <p className="text-xs text-green-600 font-medium">
                  File uploaded successfully!
                </p>
              </div>
            )}

            {/* Show normal content when not uploading or complete */}
            {uploadStatus !== "uploading" && uploadStatus !== "success" && (
              <>
                {/* Info Box - Only for multiple files */}
                {getInfoBox()}

                {/* Drag & Drop Area */}
                <div
                  className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
                    state.dragActive
                      ? "border-blue-400 bg-blue-50"
                      : state.selectedFile
                      ? "border-blue-400 bg-blue-50"
                      : "border-gray-300 bg-gray-50"
                  }`}
                  onDragEnter={handlers.handleDrag}
                  onDragLeave={handlers.handleDrag}
                  onDragOver={handlers.handleDrag}
                  onDrop={handlers.handleDrop}
                >
                  {getDragDropContent()}
                </div>

                {/* Analyzing ZIP state */}
                {isAnalyzing && (
                  <div className="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md flex items-center justify-center gap-2 text-blue-700">
                    <div className="animate-spin rounded-full h-4 w-4 border-2 border-blue-200 border-t-blue-600"></div>
                    <span className="text-sm">Analyzing ZIP file...</span>
                  </div>
                )}

                {/* ZIP Analysis Results */}
                {zipAnalysis && (
                  <div className="mt-4 p-4 bg-green-50 border border-green-200 rounded-md">
                    <div className="flex items-center gap-2 mb-3">
                      <CheckCircle className="h-5 w-5 text-green-600" />
                      <h3 className="text-sm font-medium text-green-900">
                        ZIP Analysis Complete
                      </h3>
                    </div>

                    <div className="space-y-2 text-sm text-green-800">
                      <p>
                        <strong>Mode:</strong>{" "}
                        {zipAnalysis.isSingleCreative
                          ? "Single Creative"
                          : "Multiple Creatives"}
                      </p>
                      <p>
                        <strong>Files:</strong> {zipAnalysis.counts.total} total
                      </p>
                      <p>
                        <strong>HTML:</strong> {zipAnalysis.counts.htmls}
                      </p>
                      <p>
                        <strong>Images:</strong> {zipAnalysis.counts.images}
                      </p>
                      <p>
                        <strong>Others:</strong> {zipAnalysis.counts.others}
                      </p>
                    </div>

                    {/* Preview of analyzed items */}
                    <div className="mt-3 space-y-2">
                      {zipAnalysis.items.slice(0, 5).map((item) => (
                        <div
                          key={item.id}
                          className="flex items-center gap-2 p-2 bg-white rounded border"
                        >
                          {item.type === "html" ? (
                            <FileText className="h-4 w-4 text-blue-500" />
                          ) : item.type === "image" ? (
                            <Image className="h-4 w-4 text-green-500" />
                          ) : (
                            <div className="h-4 w-4 bg-gray-300 rounded" />
                          )}
                          <span className="text-xs text-gray-700 truncate flex-1">
                            {item.name}
                          </span>
                          <span className="text-xs text-gray-500">
                            {formatFileSize(item.size)}
                          </span>
                        </div>
                      ))}
                      {zipAnalysis.items.length > 5 && (
                        <p className="text-xs text-gray-500 text-center">
                          +{zipAnalysis.items.length - 5} more files
                        </p>
                      )}
                    </div>
                  </div>
                )}

                {/* File Input */}
                <input
                  type="file"
                  id="file-upload"
                  className="hidden"
                  onChange={handlers.handleFileInput}
                  accept={config.ACCEPT_EXTENSIONS}
                />

                {/* Browse Button - Only show when no file is selected */}
                {!state.selectedFile && (
                  <div className="mt-4 text-center">
                    <Button
                      variant="outline"
                      onClick={() => document.getElementById("file-upload")?.click()}
                      className="w-full"
                    >
                      Browse {uploadType === "single" ? "Files" : "ZIP Files"}
                    </Button>
                  </div>
                )}

                {/* Error Message */}
                {state.errorMessage && (
                  <div className="mt-4 p-3 bg-red-50 border border-red-200 rounded-md flex items-center gap-2">
                    <AlertCircle className="h-4 w-4 text-red-500" />
                    <p className="text-sm text-red-700">{state.errorMessage}</p>
                  </div>
                )}

                {/* File Info */}
                {getFileInfo()}

                {/* Close button when ZIP analysis is complete */}
                {zipAnalysis && (
                  <div className="mt-4 text-center space-y-3">
                    {/* From & Subject Lines button - Only show when creativeType is email */}
                    {creativeType === 'email' && (
                      <Button
                        variant="outline"
                        onClick={() => setIsFromSubjectLinesModalOpen(true)}
                        className="w-full border-green-300 text-green-700 hover:bg-green-50"
                      >
                        <PencilLine className="h-4 w-4 mr-2" />
                        From & Subject Lines
                      </Button>
                    )}
                    
                    <Button
                      onClick={handleClose}
                      className="w-full bg-green-600 hover:bg-green-700"
                    >
                      Close
                    </Button>
                  </div>
                )}
              </>
            )}
          </div>
        </div>
      </div>
    );
  };

  export default FileUploadModal;

================================================================================
FILE: app/api/creative/get-metadata/route.ts
================================================================================

  import { NextRequest, NextResponse } from "next/server";
  import { getPool } from "@/lib/db";

  export const runtime = "nodejs";

  export async function GET(req: NextRequest) {
    try {
      const { searchParams } = new URL(req.url);
      const creativeId = searchParams.get("creativeId");

      if (!creativeId) {
        return NextResponse.json(
          { error: "creativeId is required" },
          { status: 400 }
        );
      }

      const pool = getPool();
      const client = await pool.connect();

      try {
        // Get existing metadata for the creative
        const result = await client.query(
          `SELECT from_lines, subject_lines, proofreading_data, html_content, metadata 
          FROM creative_metadata 
          WHERE creative_id = $1`,
          [creativeId]
        );

        if (result.rows.length > 0) {
          const metadata = result.rows[0];
          return NextResponse.json({
            success: true,
            metadata: {
              fromLines: metadata.from_lines,
              subjectLines: metadata.subject_lines,
              proofreadingData: metadata.proofreading_data,
              htmlContent: metadata.html_content,
              additionalMetadata: metadata.metadata,
            }
          });
        } else {
          // No existing metadata found
          return NextResponse.json({
            success: true,
            metadata: null,
            message: "No existing metadata found for this creative"
          });
        }
      } finally {
        client.release();
      }
    } catch (e) {
      console.error("get creative metadata error:", e);
      return NextResponse.json(
        { error: "Failed to retrieve creative metadata", detail: e instanceof Error ? e.message : String(e) }, 
        { status: 500 }
      );
    }
  }

================================================================================
FILE: app/api/creative/rename/route.ts
================================================================================

  import { NextRequest, NextResponse } from "next/server";
  import { getFilePath } from "@/lib/fileStorage";
  import { rename as fsRename } from "fs/promises";

  export const runtime = "nodejs";

  export async function POST(req: NextRequest) {
    try {
      const { fileUrl, newName } = (await req.json()) as { fileUrl?: string; newName: string };
      if (!fileUrl || !newName) {
        return NextResponse.json({ error: "fileUrl and newName required" }, { status: 400 });
      }

      const m = fileUrl.match(/\/api\/files\/([^/]+)\/([^?#]+)/);
      if (!m) return NextResponse.json({ error: "bad fileUrl" }, { status: 400 });
      const id = decodeURIComponent(m[1]);
      const oldName = decodeURIComponent(m[2]);

      const oldAbs = await getFilePath(id, oldName);
      const newAbs = await getFilePath(id, newName);
      await fsRename(oldAbs, newAbs);

      return NextResponse.json({
        ok: true,
        newName,
        fileUrl: `/api/files/${encodeURIComponent(id)}/${encodeURIComponent(newName)}`,
      });
    } catch (e) {
      console.error("rename error:", e);
      return NextResponse.json({ error: "Failed to rename" }, { status: 500 });
    }
  }

================================================================================
FILE: app/api/files/bulk-delete/route.ts
================================================================================

  import { NextRequest, NextResponse } from 'next/server';
  import { deleteFileTreeById, getFileDir } from '@/lib/fileStorage';
  import { stat } from 'fs/promises';

  export const dynamic = 'force-dynamic';

  type Req = { ids: string[] };

  export async function POST(req: NextRequest) {
    try {
      const { ids } = (await req.json()) as Req;
      if (!Array.isArray(ids) || !ids.length) {
        return NextResponse.json({ error: 'ids[] required' }, { status: 400 });
      }

      const results = [];
      let reclaimed = 0;

      for (const id of ids) {
        try {
          await stat(getFileDir(id)); // exists?
          const r = await deleteFileTreeById(id);
          reclaimed += r.bytesReclaimed;
          results.push({ id, ok: true, deleted: r.filesDeleted.length, bytes: r.bytesReclaimed });
        } catch {
          results.push({ id, ok: false, reason: 'not-found' });
        }
      }

      return NextResponse.json({ success: true, results, totalReclaimed: reclaimed });
    } catch (e) {
      console.error('Bulk delete error:', e);
      return NextResponse.json({ error: 'Failed bulk-delete' }, { status: 500 });
    }
  }

================================================================================
FILE: lib/db.ts
================================================================================

  import { Pool } from "pg";

  declare global {
    // allow global var in dev hot-reload
    var __pgPool__: Pool | undefined;
  }

  export function getPool(): Pool {
    const exists = globalThis.__pgPool__;
    if (exists) return exists;

    const url = process.env.DATABASE_URL;
    if (!url) throw new Error("DATABASE_URL env var is required");

    const pool = new Pool({
      connectionString: url,
      ssl: { rejectUnauthorized: false },
      max: 3,
      idleTimeoutMillis: 10000,
      connectionTimeoutMillis: 5000,
    });

    globalThis.__pgPool__ = pool;
    return pool;
  }

  async function init() {
    const pool = getPool();
    
    await pool.query(`
      CREATE TABLE IF NOT EXISTS telegram_users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(255) UNIQUE NOT NULL,
        chat_id BIGINT NOT NULL,
        first_name VARCHAR(255),
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);
    
    await pool.query(`
      CREATE TABLE IF NOT EXISTS creatives (
        id UUID PRIMARY KEY,
        affiliate_id TEXT,
        company_name TEXT,
        first_name TEXT,
        last_name TEXT,
        email TEXT,
        telegram_id TEXT,
        offer_id TEXT,
        creative_type TEXT,
        from_lines TEXT,
        subject_lines TEXT,
        notes TEXT,
        priority TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      );
    `);
    
    await pool.query(`
      CREATE TABLE IF NOT EXISTS creative_files (
        id UUID PRIMARY KEY,
        creative_id UUID REFERENCES creatives(id) ON DELETE CASCADE,
        file_name TEXT,
        file_url TEXT,
        file_type TEXT,
        file_size BIGINT
      );
    `);
    
    await pool.query(`
      CREATE TABLE IF NOT EXISTS telegram_state (
        key TEXT PRIMARY KEY,
        value TEXT,
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    await pool.query(`
      CREATE TABLE IF NOT EXISTS submissions (
        id SERIAL PRIMARY KEY,
        offer_id TEXT NOT NULL,
        priority TEXT,
        contact_method TEXT,
        contact_info TEXT NOT NULL,
        from_lines TEXT,
        subject_lines TEXT,
        other_request TEXT,
        affiliate_id TEXT,
        company_name TEXT,
        telegram_id TEXT,
        creative_type TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      );
    `);
    
    await pool.query(`
      CREATE TABLE IF NOT EXISTS submission_files (
        id SERIAL PRIMARY KEY,
        submission_id INTEGER REFERENCES submissions(id) ON DELETE CASCADE,
        file_url TEXT,
        file_key TEXT,
        original_filename TEXT,
        creative_from_lines TEXT,
        creative_subject_lines TEXT,
        creative_notes TEXT,
        creative_html_code TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      );
    `);

    await pool.query(`
      CREATE TABLE IF NOT EXISTS creative_metadata (
        id SERIAL PRIMARY KEY,
        creative_id TEXT NOT NULL,
        from_lines TEXT,
        subject_lines TEXT,
        proofreading_data JSONB,
        html_content TEXT,
        metadata JSONB,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);

    // Add missing columns to existing submissions table if they don't exist
    await pool.query(`
      ALTER TABLE submissions 
      ADD COLUMN IF NOT EXISTS affiliate_id TEXT,
      ADD COLUMN IF NOT EXISTS company_name TEXT,
      ADD COLUMN IF NOT EXISTS telegram_id TEXT,
      ADD COLUMN IF NOT EXISTS creative_type TEXT;
    `);
  }

  init().catch((error) => {
    console.error("Failed to initialize database tables:", error);
  });

================================================================================
FILE: lib/rateLimit.ts
================================================================================

  type Bucket = { tokens: number; last: number };
  const globalAny = globalThis as { __RL__?: Map<string, Bucket> };
  if (!globalAny.__RL__) globalAny.__RL__ = new Map<string, Bucket>();
  const RL: Map<string, Bucket> = globalAny.__RL__;

  export function rateLimit(key: string, opts = { capacity: 10, refillPerSec: 1 }): boolean {
    const now = Date.now();
    const b = RL.get(key) || { tokens: opts.capacity, last: now };
    const elapsed = (now - b.last) / 1000;
    b.tokens = Math.min(opts.capacity, b.tokens + elapsed * opts.refillPerSec);
    b.last = now;
    if (b.tokens < 1) { RL.set(key, b); return false; }
    b.tokens -= 1; RL.set(key, b);
    return true;
  }

================================================================================
FILE: lib/progressStore.ts
================================================================================

  type ProgressState =
    | { status: 'queued' | 'running'; pct: number; note?: string; meta?: unknown }
    | { status: 'done'; pct: 100; result?: unknown; meta?: unknown }
    | { status: 'error'; pct: number; error: string; meta?: unknown };

  const GLOBAL = globalThis as { __PROGRESS_KV__?: Map<string, { value: ProgressState; expiresAt: number }> };
  if (!GLOBAL.__PROGRESS_KV__) GLOBAL.__PROGRESS_KV__ = new Map<string, { value: ProgressState; expiresAt: number }>();
  const KV: Map<string, { value: ProgressState; expiresAt: number }> = GLOBAL.__PROGRESS_KV__;

  const DEFAULT_TTL_MS = 30 * 60 * 1000; 

  function now() { return Date.now(); }
  function gc() {
    const t = now();
    for (const [k, v] of KV.entries()) if (v.expiresAt <= t) KV.delete(k);
  }

  export function progressStart(id: string, meta?: unknown, ttlMs = DEFAULT_TTL_MS) {
    gc();
    KV.set(id, { value: { status: 'queued', pct: 0, meta }, expiresAt: now() + ttlMs });
  }

  export function progressUpdate(id: string, pct: number, note?: string, metaPatch?: unknown, ttlMs = DEFAULT_TTL_MS) {
    const cur = KV.get(id)?.value;
    const mergedMeta = { ...(cur as { meta?: Record<string, unknown> })?.meta, ...(metaPatch as Record<string, unknown> || {}) };
    KV.set(id, {
      value: { status: 'running', pct: Math.max(0, Math.min(99, Math.round(pct))), note, meta: mergedMeta },
      expiresAt: now() + ttlMs
    });
  }

  export function progressDone(id: string, result?: unknown, ttlMs = DEFAULT_TTL_MS) {
    KV.set(id, { value: { status: 'done', pct: 100, result }, expiresAt: now() + ttlMs });
  }

  export function progressError(id: string, error: string, pct = 0, ttlMs = DEFAULT_TTL_MS) {
    KV.set(id, { value: { status: 'error', pct, error }, expiresAt: now() + ttlMs });
  }

  export function progressGet(id: string): ProgressState | null {
    gc();
    const v = KV.get(id);
    return v ? v.value : null;
  }

================================================================================
FILE: components/modals/MultipleCreativeView.tsx
================================================================================

  "use client";

  import React, { useState } from "react";
  import { Button } from "@/components/ui/button";
  import { Label } from "@/components/ui/label";
  import { Textarea } from "@/components/ui/textarea";
  import { FileText, Image, File, Minimize2, FileArchive } from "lucide-react";
  import { formatFileSize, getFileType } from "@/constants";
  import SingleCreativeView from "./SingleCreativeView";
  import { renameCreative } from "@/lib/creativeClient";
  import { ImagePreview } from "@/components/ui/ImagePreview";
  import { bulkDeleteByIds, parseIdsFromUrl } from "@/lib/filesClient";

  interface MultipleCreativeViewProps {
    isOpen: boolean;
    onClose: () => void;
    creatives: Array<{
      id: string;
      name: string;
      url: string;
      size: number;
      type: string;
      previewUrl?: string;
      html?: boolean;
      uploadId?: string; // Add uploadId for asset mapping
    }>;
    zipFileName?: string;
    onRemoveCreative?: (creativeId: string) => void;
    onFileNameChange?: (fileId: string, newFileName: string) => void;
  }

  const MultipleCreativeView: React.FC<MultipleCreativeViewProps> = ({
    isOpen,
    onClose,
    creatives,
    zipFileName,
    onRemoveCreative,
    onFileNameChange,
  }) => {
    const [currentCreativeIndex, setCurrentCreativeIndex] = useState(0);
    const [isHtmlEditorFullscreen, setIsHtmlEditorFullscreen] = useState(false);
    const [isImagePreviewFullscreen, setIsImagePreviewFullscreen] =
      useState(false);

    // SingleCreativeView state
    const [isSingleCreativeViewOpen, setIsSingleCreativeViewOpen] =
      useState(false);
    const [selectedCreative, setSelectedCreative] = useState<
      MultipleCreativeViewProps["creatives"][0] | null
    >(null);

    // HTML content state for editing
    const [htmlContent, setHtmlContent] = useState("");

    // CRUD operations state
    const [isDeleting, setIsDeleting] = useState<string | null>(null);
    const [isRenaming, setIsRenaming] = useState<string | null>(null);
    const [editingName, setEditingName] = useState<string>("");

    // Current creative
    const currentCreative = creatives[currentCreativeIndex];

    // Prevent background scrolling when modal is open
    React.useEffect(() => {
      if (isOpen) {
        // Store current scroll position
        const scrollY = window.scrollY;
        document.body.style.position = "fixed";
        document.body.style.top = `-${scrollY}px`;
        document.body.style.width = "100%";
        document.body.style.overflow = "hidden";
      } else {
        // Restore scroll position and body styles
        const scrollY = document.body.style.top;
        document.body.style.position = "";
        document.body.style.top = "";
        document.body.style.width = "";
        document.body.style.overflow = "";
        if (scrollY) {
          window.scrollTo(0, parseInt(scrollY || "0") * -1);
        }
      }

      // Cleanup function to restore scrolling when component unmounts
      return () => {
        const scrollY = document.body.style.top;
        document.body.style.position = "";
        document.body.style.top = "";
        document.body.style.width = "";
        document.body.style.overflow = "";
        if (scrollY) {
          window.scrollTo(0, parseInt(scrollY || "0") * -1);
        }
      };
    }, [isOpen]);

    // Load HTML content when creative changes for HTML creatives
    React.useEffect(() => {
      if (
        isOpen &&
        currentCreative &&
        (currentCreative.type?.includes("html") ||
          currentCreative.name.toLowerCase().includes(".html"))
      ) {
        console.log("Loading HTML content for HTML creative...");
        fetchHtmlContent();
      }
    }, [isOpen, currentCreative]); // fetchHtmlContent is defined inline and doesn't need to be a dependency

    // Function to fetch HTML content from uploaded file
    const fetchHtmlContent = async () => {
      if (!currentCreative) return;

      try {
        console.log("Fetching HTML content from:", currentCreative.url);

        // First, try to get the file content from our API endpoint
        const encodedFileUrl = encodeURIComponent(currentCreative.url);
        
        // Build the API URL with uploadId if available
        let apiUrl = `/api/get-file-content?fileId=${currentCreative.id}&fileUrl=${encodedFileUrl}&processAssets=true`;
        if (currentCreative.uploadId) {
          apiUrl += `&uploadId=${encodeURIComponent(currentCreative.uploadId)}`;
        }
        
        const apiResponse = await fetch(apiUrl, {
          method: "GET",
          headers: {
            Accept:
              "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
          },
        });

        if (apiResponse.ok) {
          const htmlText = await apiResponse.text();
          console.log("HTML content loaded via API, length:", htmlText.length);
          setHtmlContent(htmlText);
          return;
        } else {
          console.log("API response not OK, status:", apiResponse.status);
        }

        // If API fails, try to fetch directly from the uploaded URL
        console.log("API failed, trying direct URL fetch...");
        const directResponse = await fetch(currentCreative.url, {
          method: "GET",
          headers: {
            Accept:
              "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
          },
          mode: "cors",
        });

        if (directResponse.ok) {
          const htmlText = await directResponse.text();
          console.log("HTML content loaded directly, length:", htmlText.length);
          setHtmlContent(htmlText);
        } else {
          // Final fallback
          console.log("All methods failed, using fallback content");
          setHtmlContent(`<!-- HTML Content Loading Failed -->
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>HTML Creative Editor</title>
      <style>
          body {
              font-family: Arial, sans-serif;
              padding: 20px;
              background: #f5f5f5;
              color: #333;
          }
          .message {
              background: white;
              padding: 20px;
              border-radius: 8px;
              border-left: 4px solid #ff6b6b;
              margin: 20px 0;
          }
      </style>
  </head>
  <body>
      <div class="message">
          <h3>⚠️ Unable to load original HTML content</h3>
          <p>You can start editing by replacing this content with your HTML code.</p>
      </div>
  </body>
  </html>`);
        }
      } catch (error) {
        console.log("Fetch error, using fallback content...");
        console.error("Error details:", error);
        setHtmlContent(`<!-- HTML Content Loading Failed -->
  <!DOCTYPE html>
  <html>
  <body>
      <div style="padding: 20px; font-family: Arial, sans-serif;">
          <h3>⚠️ Unable to load HTML content</h3>
          <p>Please try refreshing or contact support.</p>
      </div>
  </body>
  </html>`);
      }
    };

    if (!isOpen) return null;

    const handleSaveHtml = async () => {
      console.log("Saving HTML changes for creative:", currentCreative?.id);
    };

    // HTML Editor fullscreen toggle
    const toggleHtmlEditorFullscreen = () => {
      setIsHtmlEditorFullscreen(!isHtmlEditorFullscreen);
    };

    // Image Preview fullscreen toggle
    const toggleImagePreviewFullscreen = () => {
      setIsImagePreviewFullscreen(!isImagePreviewFullscreen);
    };

    // SingleCreativeView handlers
    const openSingleCreativeView = (
      creative: MultipleCreativeViewProps["creatives"][0]
    ) => {
      setSelectedCreative(creative);
      setIsSingleCreativeViewOpen(true);
    };

    const closeSingleCreativeView = () => {
      setIsSingleCreativeViewOpen(false);
      setSelectedCreative(null);
    };

    const handleFileNameChangeFromSingle = (
      fileId: string,
      newFileName: string
    ) => {
      // Update the creative in the creatives array
      const updatedCreatives = creatives.map((creative) =>
        creative.id === fileId ? { ...creative, name: newFileName } : creative
      );

      // Update selected creative if it's the one being edited
      if (selectedCreative?.id === fileId) {
        setSelectedCreative({ ...selectedCreative, name: newFileName });
      }

      // Propagate the change to parent component
      onFileNameChange?.(fileId, newFileName);
    };

    // CRUD operations
    const handleDeleteCreative = async (creative: (typeof creatives)[0]) => {
      if (!confirm(`Are you sure you want to delete "${creative.name}"?`)) {
        return;
      }

      try {
        setIsDeleting(creative.id);

        const ids = new Set<string>();
        ids.add(creative.id);

        if (creative.previewUrl) {
          const previewId = parseIdsFromUrl(creative.previewUrl).id;
          if (previewId) ids.add(previewId);
        }

        await bulkDeleteByIds(Array.from(ids));

        onRemoveCreative?.(creative.id);

        if (currentCreative?.id === creative.id && creatives.length > 1) {
          const currentIndex = creatives.findIndex((c) => c.id === creative.id);
          const nextIndex =
            currentIndex === creatives.length - 1
              ? currentIndex - 1
              : currentIndex + 1;
          setCurrentCreativeIndex(nextIndex);
        }
      } catch (error) {
        console.error("Failed to delete creative:", error);
      } finally {
        setIsDeleting(null);
      }
    };

    const handleRenameCreative = async (
      creative: (typeof creatives)[0],
      newName: string
    ) => {
      if (!newName.trim() || newName === creative.name) {
        setIsRenaming(null);
        setEditingName("");
        return;
      }

      try {
        setIsRenaming(creative.id);
        await renameCreative({
          creativeId: creative.id,
          fileUrl: creative.url,
          newName: newName.trim(),
        });

        // Update local state
        onFileNameChange?.(creative.id, newName.trim());

        // Update selected creative if it's the one being renamed
        if (selectedCreative?.id === creative.id) {
          setSelectedCreative({ ...selectedCreative, name: newName.trim() });
        }
      } catch (error) {
        console.error("Failed to rename creative:", error);
      } finally {
        setIsRenaming(null);
        setEditingName("");
      }
    };

    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 animate-in fade-in duration-200">
        <div className="bg-white w-full h-full flex flex-col animate-in zoom-in-95 duration-200">
          {/* Header - Single Row Layout */}
          <div className="flex items-center justify-between p-4 sm:p-6 border-b border-gray-200 bg-gradient-to-r from-purple-50 to-blue-50 gap-3 sm:gap-4">
            <div className="flex items-center gap-2 sm:gap-4 min-w-0 flex-1">
              <div className="p-2 sm:p-3 bg-purple-100 rounded-xl shadow-sm flex-shrink-0">
                <FileArchive className="h-5 w-5 sm:h-6 sm:w-6 text-purple-600" />
              </div>
              <div className="min-w-0 flex-1">
                <h2 className="text-sm sm:text-lg lg:text-xl font-semibold text-gray-900 mb-0.5 sm:mb-1 truncate">
                  {zipFileName || "Multiple Creatives"}
                </h2>
                <div className="flex items-center gap-1 sm:gap-2">
                  <span className="inline-flex items-center px-1.5 sm:px-2 py-0.5 sm:py-1 rounded-full text-xs font-medium bg-purple-100 text-purple-800">
                    {creatives.length} files
                  </span>
                  <span className="text-gray-600 text-xs">•</span>
                  <span className="text-xs text-gray-600">ZIP Archive</span>
                </div>
              </div>
            </div>

            <Button
              variant="default"
              size="sm"
              onClick={onClose}
              className="px-3 sm:px-4 lg:px-6 py-1.5 sm:py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg shadow-sm transition-all duration-150 hover:shadow-md text-xs sm:text-sm flex-shrink-0"
            >
              <span>Save and Continue</span>
            </Button>
          </div>

          {/* Content - Responsive Card Layout */}
          <div className="flex-1 overflow-hidden">
            <div className="h-full p-3 sm:p-4 lg:p-6 bg-gray-50 overflow-y-auto">
              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6 gap-3 sm:gap-4">
                {creatives.map((creative) => {
                  const fileType = getFileType(creative.name);
                  const isImage = fileType === "image";
                  const isHtml = fileType === "html";

                  return (
                    <div
                      key={creative.id}
                      className="bg-white rounded-lg border border-gray-200 shadow-sm hover:shadow-md hover:border-blue-200 transition-all duration-200 overflow-hidden group"
                    >
                      {/* Preview Section */}
                      <div className="aspect-[4/3] bg-gray-50 overflow-hidden relative">
                        {isImage ? (
                          <ImagePreview
                            src={creative.previewUrl || creative.url}
                            alt={creative.name}
                            fileName={creative.name}
                            className="w-full h-full object-cover"
                          />
                        ) : isHtml ? (
                          <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-emerald-50 to-green-50">
                            <div className="text-center">
                              <FileText className="h-10 w-10 text-emerald-600 mx-auto mb-2" />
                              <p className="text-xs font-medium text-emerald-700">
                                HTML
                              </p>
                            </div>
                          </div>
                        ) : (
                          <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-slate-50 to-gray-50">
                            <div className="text-center">
                              <File className="h-10 w-10 text-slate-500 mx-auto mb-2" />
                              <p className="text-xs font-medium text-slate-600">
                                File
                              </p>
                            </div>
                          </div>
                        )}

                        {/* Action Buttons - Top Right */}
                        <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex gap-1">
                          {/* Rename Button */}
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={(e) => {
                              e.stopPropagation();
                              setEditingName(creative.name);
                              setIsRenaming(creative.id);
                            }}
                            disabled={isRenaming === creative.id}
                            className="h-6 sm:h-7 px-1.5 sm:px-2 bg-white/95 border-blue-200 text-blue-600 hover:bg-blue-50 hover:text-blue-700 hover:border-blue-300 text-xs font-medium shadow-sm"
                          >
                            <span className="hidden sm:inline">Rename</span>
                            <span className="sm:hidden">✏️</span>
                          </Button>

                          {/* Delete Button */}
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={(e) => {
                              e.stopPropagation();
                              handleDeleteCreative(creative);
                            }}
                            disabled={isDeleting === creative.id}
                            className="h-6 sm:h-7 px-1.5 sm:px-2 bg-white/95 border-red-200 text-red-600 hover:bg-red-50 hover:text-red-700 hover:border-red-300 text-xs font-medium shadow-sm"
                          >
                            {isDeleting === creative.id ? (
                              <div className="w-3 h-3 border border-red-600 border-t-transparent rounded-full animate-spin" />
                            ) : (
                              <>
                                <span className="hidden sm:inline">Delete</span>
                                <span className="sm:hidden">×</span>
                              </>
                            )}
                          </Button>
                        </div>
                      </div>

                      {/* Content Section */}
                      <div className="p-3 sm:p-4">
                        {/* Filename and File Info */}
                        <div className="mb-3">
                          {isRenaming === creative.id ? (
                            <div className="flex gap-1 mb-2">
                              <input
                                type="text"
                                value={editingName}
                                onChange={(e) => setEditingName(e.target.value)}
                                onKeyDown={(e) => {
                                  if (e.key === "Enter") {
                                    handleRenameCreative(creative, editingName);
                                  } else if (e.key === "Escape") {
                                    setIsRenaming(null);
                                    setEditingName("");
                                  }
                                }}
                                className="flex-1 text-xs sm:text-sm border border-blue-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                autoFocus
                              />
                              <Button
                                size="sm"
                                onClick={() =>
                                  handleRenameCreative(creative, editingName)
                                }
                                disabled={isRenaming === creative.id}
                                className="h-6 sm:h-7 px-2 bg-blue-600 hover:bg-blue-700 text-white text-xs"
                              >
                                {isRenaming === creative.id ? (
                                  <div className="w-3 h-3 border border-white border-t-transparent rounded-full animate-spin" />
                                ) : (
                                  "✓"
                                )}
                              </Button>
                              <Button
                                size="sm"
                                variant="outline"
                                onClick={() => {
                                  setIsRenaming(null);
                                  setEditingName("");
                                }}
                                className="h-6 sm:h-7 px-2 border-gray-300 text-gray-600 hover:bg-gray-50 text-xs"
                              >
                                ×
                              </Button>
                            </div>
                          ) : (
                            <h3
                              className="font-medium text-gray-900 text-xs sm:text-sm truncate mb-1"
                              title={creative.name}
                            >
                              {creative.name}
                            </h3>
                          )}
                          <div className="flex items-center justify-between text-xs text-gray-500">
                            <span
                              className={`inline-flex items-center px-1.5 sm:px-2 py-0.5 rounded-full font-medium text-xs ${
                                isImage
                                  ? "bg-blue-50 text-blue-600"
                                  : isHtml
                                  ? "bg-emerald-50 text-emerald-600"
                                  : "bg-gray-50 text-gray-600"
                              }`}
                            >
                              {fileType}
                            </span>
                            <span className="font-medium text-xs">
                              {formatFileSize(creative.size)}
                            </span>
                          </div>
                        </div>

                        {/* View Button */}
                        <Button
                          onClick={() => {
                            openSingleCreativeView(creative);
                          }}
                          className="w-full bg-blue-400 hover:bg-blue-600 text-white font-medium py-1.5 sm:py-2 px-2 sm:px-3 rounded-md text-xs sm:text-sm transition-colors duration-200 mb-2"
                        >
                          <span>View Creative</span>
                        </Button>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        </div>

        {/* Fullscreen HTML Editor Modal */}
        {isHtmlEditorFullscreen && (
          <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[60] animate-in fade-in duration-200">
            <div className="bg-white w-full h-full flex flex-col shadow-2xl animate-in zoom-in-95 duration-200">
              {/* Fullscreen Header */}
              <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between p-4 sm:p-6 border-b border-gray-200 gap-3 sm:gap-0">
                <div className="flex items-center gap-3">
                  <div className="p-2 bg-orange-100 rounded-lg">
                    <FileText className="h-5 w-5 text-orange-600" />
                  </div>
                  <h2 className="text-lg sm:text-xl font-semibold text-gray-800 truncate">
                    HTML Editor - {currentCreative?.name}
                  </h2>
                </div>

                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={toggleHtmlEditorFullscreen}
                    className="flex items-center gap-2 text-purple-700 border-purple-300 hover:bg-purple-50 hover:text-purple-800 transition-colors flex-1 sm:flex-initial"
                  >
                    <Minimize2 className="h-4 w-4" />
                    Exit Fullscreen
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={handleSaveHtml}
                    className="flex items-center gap-2 text-orange-700 border-orange-300 hover:bg-orange-50 hover:text-orange-800 transition-colors flex-1 sm:flex-initial"
                  >
                    <FileText className="h-4 w-4" />
                    Save Changes
                  </Button>
                </div>
              </div>

              {/* Fullscreen Content - Responsive Split View */}
              <div className="flex-1 flex flex-col lg:flex-row overflow-hidden">
                {/* HTML Editor */}
                <div className="lg:w-1/2 lg:border-r border-gray-200 flex flex-col min-h-0">
                  <div className="p-3 sm:p-4 border-b border-gray-200">
                    <Label className="text-xs sm:text-sm font-semibold text-gray-700 uppercase tracking-wide">
                      HTML Code
                    </Label>
                  </div>
                  <div className="flex-1 p-3 sm:p-4">
                    <Textarea
                      value={htmlContent}
                      onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
                        setHtmlContent(e.target.value)
                      }
                      placeholder="Edit your HTML code here..."
                      className="w-full h-full resize-none text-xs sm:text-sm font-mono border-gray-300 focus:border-orange-500 focus:ring-orange-500/20"
                    />
                  </div>
                </div>

                {/* Live Preview */}
                <div className="lg:w-1/2 flex flex-col min-h-0 border-t lg:border-t-0 border-gray-200">
                  <div className="p-3 sm:p-4 border-b border-gray-200">
                    <Label className="text-xs sm:text-sm font-semibold text-gray-700 uppercase tracking-wide">
                      Live Preview
                    </Label>
                  </div>
                  <div className="flex-1 bg-gray-50 min-h-[300px] lg:min-h-0">
                    <iframe
                      srcDoc={
                        htmlContent ||
                        '<div style="display:flex;align-items:center;justify-content:center;height:100vh;font-family:Arial,sans-serif;color:#666;"><p>HTML content will appear here</p></div>'
                      }
                      title="HTML Preview - Fullscreen"
                      className="w-full h-full border-0"
                      sandbox="allow-scripts allow-same-origin"
                    />
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Fullscreen Image Preview Modal */}
        {isImagePreviewFullscreen &&
          currentCreative &&
          getFileType(currentCreative.name) === "image" &&
          (currentCreative.previewUrl || currentCreative.url) && (
            <div className="fixed inset-0 bg-black bg-opacity-95 flex items-center justify-center z-[60] animate-in fade-in duration-200">
              <div className="relative w-full h-full flex items-center justify-center p-4 sm:p-8">
                {/* Exit Fullscreen Button */}
                <Button
                  variant="outline"
                  size="sm"
                  onClick={toggleImagePreviewFullscreen}
                  className="absolute top-3 sm:top-6 right-3 sm:right-6 flex items-center gap-2 text-white border-white/30 hover:bg-white/10 hover:text-white transition-colors z-10"
                >
                  <Minimize2 className="h-4 w-4" />
                  <span>Exit Fullscreen</span>
                </Button>

                {/* Header with filename */}
                <div className="absolute top-3 sm:top-6 left-3 sm:left-6 flex items-center gap-3 text-white z-10">
                  <div className="p-2 bg-white/20 rounded-lg backdrop-blur-sm">
                    <Image className="h-4 w-4 sm:h-5 sm:w-5" />
                  </div>
                  <h2 className="text-sm sm:text-lg font-semibold truncate max-w-[200px] sm:max-w-none">
                    {currentCreative?.name}
                  </h2>
                </div>

                {/* Fullscreen Image */}
                <div onClick={(e) => e.stopPropagation()}>
                  <ImagePreview
                    src={currentCreative?.previewUrl || currentCreative?.url}
                    alt={currentCreative?.name}
                    fileName={currentCreative?.name}
                    className="max-w-[90vw] max-h-[80vh] object-contain rounded-lg shadow-2xl"
                  />
                </div>

                {/* Click outside to close */}
                <div
                  className="absolute inset-0 cursor-pointer"
                  onClick={toggleImagePreviewFullscreen}
                />
              </div>
            </div>
          )}

        {/* SingleCreativeView Modal */}
        {selectedCreative && (
          <SingleCreativeView
            isOpen={isSingleCreativeViewOpen}
            onClose={closeSingleCreativeView}
            creative={selectedCreative}
            onFileNameChange={handleFileNameChangeFromSingle}
          />
        )}
      </div>
    );
  };

  export default MultipleCreativeView;

=== LATEST UPDATES - PROOFREADING WITH HTML PREVIEW IMAGES ===

**IMPLEMENTED VISUAL PROOFREADING FOR HTML CREATIVES**

The proofreading system now uses complete HTML preview images instead of scanning individual image parts, providing more accurate and comprehensive analysis.

**Problem Addressed:**
- HTML creatives with images were being analyzed by extracting text content only
- Individual image parts were being scanned separately without context
- Missing visual layout and design elements in proofreading analysis
- Incomplete understanding of how the creative actually appears to users

**Solution Implemented:**

**app/api/proofread-creative/route.ts:**
- Added intelligent detection for HTML preview images
- Uses vision models to analyze complete HTML preview images
- Falls back to text extraction only when preview images aren't available
- Provides comprehensive visual analysis including layout, text, and design elements

**components/modals/SingleCreativeView.tsx:**
- Updated proofreading calls to pass preview URL for HTML creatives
- Enables visual analysis of complete creative previews

**Smart Analysis Logic:**
1. **Check for preview URL** - if HTML creative has preview image, use it
2. **Visual analysis** - use vision models to analyze complete preview
3. **Fallback to text** - if no preview available, extract and analyze text content
4. **Comprehensive feedback** - analyze layout, text, design, and user experience

**Benefits:**
- ✅ **Complete visual analysis** - sees the creative as users do
- ✅ **Better context understanding** - analyzes layout and design together
- ✅ **More accurate feedback** - considers visual hierarchy and presentation
- ✅ **Efficient processing** - one complete image vs. multiple fragments
- ✅ **Enhanced proofreading** - catches visual and textual issues together

**Analysis Coverage:**
- **Text content** - grammar, spelling, readability
- **Visual layout** - hierarchy, spacing, alignment
- **Design elements** - colors, fonts, visual appeal
- **User experience** - clarity, conversion optimization
- **Brand alignment** - consistency and professionalism

=== PREVIOUS UPDATES - COMPLETE BASE64 REMOVAL ===

**REMOVED ALL BASE64 FUNCTIONALITY FROM SYSTEM**

The system has been completely cleaned of all base64 usage. All image and asset handling now uses direct file URLs only.

**Changes Made:**

**lib/zip.ts:**
- Removed base64 embedding from `embedImagesInHTML()` function
- Images are now saved as separate files and referenced via direct URLs
- HTML content uses `/api/files/{fileId}/{fileName}` URLs instead of base64 data URLs

**app/api/get-file-content/route.ts:**
- Removed base64 fallback mechanism from `toDataURL()` function
- Simplified asset resolution to use direct URLs only
- No more fallback to base64 when direct URLs fail

**components/ui/ImagePreview.tsx:**
- Removed base64 fallback mechanism (previously done)
- Simple direct URL loading with error handling

**Benefits:**
- ✅ **No base64 data URLs** anywhere in the system
- ✅ **Cleaner HTML content** with direct file references
- ✅ **Better performance** - no large base64 strings in HTML
- ✅ **Simplified codebase** - no complex fallback logic
- ✅ **Consistent approach** - all assets use direct URLs

**Current Behavior:**
- **Images**: Direct file URLs (`/api/files/{id}/{name}`)
- **HTML Assets**: Direct file URLs (no base64 embedding)
- **Error Handling**: Simple error placeholders (no base64 fallback)

=== PREVIOUS UPDATES - HTML PREVIEW GENERATION FOR DASHBOARD ===

**IMPLEMENTED HTML PREVIEW GENERATION**

The system now generates proper preview images for HTML creatives, so they display correctly in the dashboard instead of showing generic HTML icons.

**Problem Identified:**
- HTML files were not getting `previewUrl` values generated
- Dashboard showed generic HTML icons instead of proper previews
- Only image files were getting preview URLs

**Solution Implemented:**

**lib/preview.ts:**
- Added `makeHtmlPreview()` function to generate HTML preview images
- Creates SVG-based preview showing "HTML Document" with character count
- Converts SVG to JPEG using Sharp for consistent preview format
- Generates 400x300 pixel previews for HTML files

**lib/zip.ts:**
- Updated preview generation logic to include HTML files
- HTML files now get `previewUrl` generated during ZIP processing
- Both `processRootFiles()` and `processCreativeGroup()` generate HTML previews
- Uses embedded HTML content for preview generation (includes embedded images)

**Benefits:**
- ✅ HTML creatives now show proper preview images in dashboard
- ✅ Consistent preview format across all file types
- ✅ Better visual representation of HTML content
- ✅ Maintains all existing functionality

**Preview Generation:**
- **Images**: Thumbnail generation (existing)
- **HTML**: SVG-based preview with document info (new)
- **Other files**: Generic file icons (existing)

=== PREVIOUS UPDATES - FOLDER-BASED CREATIVE GROUPING LOGIC ===

**IMPLEMENTED FOLDER-BASED CREATIVE GROUPING**

The system now implements the folder-based creative grouping logic from the previous project:

**Key Rules:**
1. **Folder has HTML + images** → Show only HTML files (hide images as separate creatives)
2. **Folder has only images (no HTML)** → Show images as separate creatives  
3. **Folder has only HTML (no images)** → Show HTML files
4. **Root files** → Same logic applies to root-level files

**How it works:**
- Files are grouped by top-level directory (folder)
- Each folder becomes a "creative group"
- If a group contains HTML files, images are embedded into the HTML and not shown as separate creatives
- If a group contains only images (no HTML), images are shown as separate creatives
- Root-level files follow the same logic

**Files Modified:**

**lib/zip.ts:**
- Completely restructured ZIP processing to implement folder-based grouping
- Added `processRootFiles()` function for root-level file processing
- Added `processCreativeGroup()` function for folder-based processing  
- Added `embedImagesInHTML()` function to embed images into HTML content
- Files are now collected first, then grouped by folder, then processed with creative grouping logic
- Added `embeddedHtml` property to extracted file objects

**app/api/get-file-content/route.ts:**
- Added support for `embeddedHtml` parameter
- If embedded HTML is provided, it's used directly (images already embedded)
- Falls back to normal processing if no embedded HTML

**app/Form/Steps/CreativeDetails.tsx:**
- Updated `ZipUploadResponse` interface to include `embeddedHtml` property
- Updated `UploadedFileMeta` type to include `embeddedHtml` property
- Modified file mapping to pass through `embeddedHtml` from backend

**components/modals/MultipleCreativeView.tsx:**
- Updated interface to include `embeddedHtml` property
- Modified API call to pass `embeddedHtml` parameter when available
- Uses embedded HTML directly when available, bypassing asset processing

**Benefits:**
- ✅ HTML files with images show only the HTML (images embedded)
- ✅ Image-only folders show images as separate creatives
- ✅ Cleaner UI with fewer duplicate files
- ✅ Better user experience matching previous project behavior
- ✅ Images are embedded as base64 data URLs in HTML
- ✅ Maintains all existing functionality

**Example Behavior:**
```
ZIP Structure:
├── email1/
│   ├── email_1.html
│   └── images/
│       ├── image1.jpg
│       └── image2.jpg
├── email2/
│   ├── email_2.html  
│   └── images/
│       └── image3.jpg
└── standalone_images/
    ├── image4.jpg
    └── image5.jpg

Result:
- email1/ → Shows only email_1.html (with embedded images)
- email2/ → Shows only email_2.html (with embedded images)  
- standalone_images/ → Shows image4.jpg and image5.jpg as separate creatives
```

=== PREVIOUS UPDATES - ASSET URL OPTIMIZATION WITH FALLBACK + ZIP SORTING FIX ===

// SMART FALLBACK MECHANISM IMPLEMENTED:
// 1. Primary: Direct file URLs for efficiency (/api/files/{fileId}/{fileName})
// 2. Fallback: Base64 encoding when direct URLs fail
// 3. Best of both worlds: Performance + Reliability
// 4. Automatic error handling and graceful degradation

// ZIP FILE SORTING FIX:
// 1. Fixed missing return statement in getFilePriority function
// 2. Added proper TypeScript type definitions for priority and originalPath fields
// 3. Enhanced sorting logic with debugging logs
// 4. HTML files now properly prioritized in ZIP processing

// CHANGES MADE:

// app/api/get-file-content/route.ts - SMART FALLBACK SYSTEM
// - Primary method: Direct file URLs for optimal performance
// - Fallback method: Base64 encoding when files can't be accessed via direct URLs
// - File existence checking before choosing method
// - Graceful error handling with detailed logging
// - Restored getMimeType function for base64 fallback
// - Added proper imports for file operations

// lib/zip.ts - ZIP SORTING FIX
// - Fixed getFilePriority function missing return statement
// - Added debugging logs for sorting process
// - Enhanced type definitions for extracted files
// - Improved sorting logic with null safety

// lib/zipPassword.ts - ENCRYPTED ZIP SORTING FIX
// - Fixed getFilePriority function missing return statement
// - Added debugging logs for encrypted file sorting
// - Enhanced type definitions for extracted files
// - Consistent sorting behavior for encrypted ZIPs

// app/api/upload-zip/route.ts - TYPE DEFINITIONS
// - Updated extracted array type to include priority, originalPath, previewUrl
// - Fixed TypeScript compilation errors
// - Ensured type safety across all ZIP processing functions

// FALLBACK LOGIC:
// 1. Try direct file URL first (preferred for performance)
// 2. Check if file exists and is readable
// 3. If direct URL fails, automatically fall back to base64
// 4. If both methods fail, return direct URL and let browser handle 404
// 5. Log all fallback attempts for debugging

// ZIP SORTING PRIORITY:
// 1. HTML files (.html, .htm) - Priority 10 (highest)
// 2. Image files - Priority 8
// 3. PDF files - Priority 6
// 4. Text files (.txt) - Priority 2
// 5. Other files - Priority 1 (lowest)

// BENEFITS:
// - Optimal performance when direct URLs work
// - Guaranteed reliability with base64 fallback
// - Automatic error recovery
// - Better debugging with fallback logging
// - No broken images due to failed asset resolution
// - HTML files properly sorted to appear first in ZIP uploads
// - Consistent sorting behavior for both regular and encrypted ZIPs

// DEBUGGING ADDED:
// - Frontend logging to track file order from backend to UI
// - Backend sorting logs show correct priority-based ordering
// - Frontend mapping preserves backend sort order
// - UI component logs display order for verification

// lib/uploadAssetIndex.ts - NEW FILE
// Manages in-memory store for UploadAssetIndex objects to enable cross-fileId asset resolution

export interface UploadAssetEntry {
  fileId: string;
  name: string;
  path: string;
  size: number;
  type: string;
}

export interface UploadAssetIndex {
  byPath: Map<string, UploadAssetEntry>;   
  byBase: Map<string, UploadAssetEntry[]>; 
}

const uploadIndexes = new Map<string, UploadAssetIndex>();

export function createUploadAssetIndex(files: Array<{
  fileId: string;
  fileName: string;
  fileSize: number;
  fileType: string;
  originalPath?: string; 
}>): UploadAssetIndex {
  const byPath = new Map<string, UploadAssetEntry>();
  const byBase = new Map<string, UploadAssetEntry[]>();

  for (const file of files) {
    const path = file.originalPath || file.fileName;
    const normalizedPath = normalizePath(path).toLowerCase();
    const basename = path.split('/').pop()?.toLowerCase() || '';

    const entry: UploadAssetEntry = {
      fileId: file.fileId,
      name: file.fileName,
      path: normalizedPath,
      size: file.fileSize,
      type: file.fileType,
    };

    byPath.set(normalizedPath, entry);

    if (basename) {
      if (!byBase.has(basename)) {
        byBase.set(basename, []);
      }
      byBase.get(basename)!.push(entry);
    }
  }

  return { byPath, byBase };
}

export function storeUploadAssetIndex(uploadId: string, index: UploadAssetIndex): void {
  uploadIndexes.set(uploadId, index);
}

export function getUploadAssetIndex(uploadId: string): UploadAssetIndex | null {
  return uploadIndexes.get(uploadId) || null;
}

export function removeUploadAssetIndex(uploadId: string): void {
  uploadIndexes.delete(uploadId);
}

function normalizePath(path: string): string {
  return path
    .replace(/\\/g, '/')           
    .replace(/^\/+/, '')           
    .replace(/\/+/g, '/')          
    .replace(/\/$/, '');           
}

export function resolveAssetInUpload(
  uploadId: string,
  htmlPath: string,
  assetRef: string
): UploadAssetEntry | null {
  const index = getUploadAssetIndex(uploadId);
  if (!index) return null;

  if (/^(data:|https?:|mailto:|javascript:)/i.test(assetRef)) {
    return null;
  }

  const relativePath = resolveRelativePath(htmlPath, assetRef);
  if (relativePath) {
    const normalizedRelative = normalizePath(relativePath).toLowerCase();
    const exactMatch = index.byPath.get(normalizedRelative);
    if (exactMatch) return exactMatch;
  }

  const rootishPath = normalizePath(assetRef).toLowerCase();
  const rootishMatch = index.byPath.get(rootishPath);
  if (rootishMatch) return rootishMatch;

  const basename = assetRef.split('/').pop()?.toLowerCase() || '';
  if (basename) {
    const basenameMatches = index.byBase.get(basename) || [];
    if (basenameMatches.length === 1) {
      return basenameMatches[0];
    }
  }

  return null;
}

function resolveRelativePath(htmlPath: string, assetRef: string): string | null {
  const htmlDir = htmlPath.split('/').slice(0, -1).join('/');
  
  const resolved = htmlDir ? `${htmlDir}/${assetRef}` : assetRef;
  
  if (resolved.includes('..')) {
    return null;
  }
  
  return resolved;
}

export function getAllAssetsForUpload(uploadId: string): UploadAssetEntry[] {
  const index = getUploadAssetIndex(uploadId);
  if (!index) return [];
  
  return Array.from(index.byPath.values());
}

// app/api/get-file-content/route.ts - UPDATED
// Now uses UploadAssetIndex for cross-fileId asset resolution and inlines assets as data URLs

import { NextResponse } from "next/server";
import { getFilePath } from "@/lib/fileStorage";
import { rewriteHtmlAssets, getAssetMapping } from "@/lib/assetRewriter";
import { getUploadAssetIndex, resolveAssetInUpload } from "@/lib/uploadAssetIndex";
import { JSDOM } from "jsdom";
import { readFile } from "fs/promises";
import path from "path";

export const dynamic = "force-dynamic";

async function rewriteHtmlAssetsWithUploadIndex(
  html: string, 
  baseUrl: string, 
  assetMapping: any, 
  uploadId: string, 
  htmlFileId: string
): Promise<string> {
  const dom = new JSDOM(html);
  const { document } = dom.window;

  const toDataURL = async (assetRef: string): Promise<string> => {
    
    if (/^(data:|https?:|mailto:|javascript:)/i.test(assetRef)) {
      return assetRef;
    }

    if (uploadId) {
      const assetEntry = resolveAssetInUpload(uploadId, htmlFileId, assetRef);
      if (assetEntry) {
        try {
          const assetPath = await getFilePath(assetEntry.fileId, assetEntry.name);
          const assetBuffer = await readFile(assetPath);
          const ext = path.extname(assetEntry.name).toLowerCase();
          const mimeType = getMimeType(ext);
          const base64 = assetBuffer.toString('base64');
          return `data:${mimeType};base64,${base64}`;
        } catch (error) {
          console.log(`Failed to inline asset ${assetRef}:`, error);
        }
      }
    }

    if (assetMapping && assetMapping[assetRef]) {
      return assetMapping[assetRef];
    }

    return `${baseUrl}${assetRef}`;
  };

  const imgElements = document.querySelectorAll('img[src]');
  for (const img of imgElements) {
    const src = img.getAttribute('src');
    if (src && !/^(data:|https?:|mailto:|javascript:)/i.test(src)) {
      const newSrc = await toDataURL(src);
      img.setAttribute('src', newSrc);
    }
  }

  const srcsetElements = document.querySelectorAll('[srcset]');
  for (const element of srcsetElements) {
    const srcset = element.getAttribute('srcset');
    if (srcset) {
      const parts = srcset.split(',').map(s => s.trim());
      const newParts = await Promise.all(parts.map(async (part) => {
        const [url, descriptor] = part.split(/\s+/);
        const newUrl = await toDataURL(url);
        return descriptor ? `${newUrl} ${descriptor}` : newUrl;
      }));
      element.setAttribute('srcset', newParts.join(', '));
    }
  }

  const styleElements = document.querySelectorAll('[style]');
  for (const element of styleElements) {
    const style = element.getAttribute('style');
    if (style) {
      const newStyle = await rewriteCssUrlsAsync(style, toDataURL);
      element.setAttribute('style', newStyle);
    }
  }

  const styleBlocks = document.querySelectorAll('style');
  for (const styleBlock of styleBlocks) {
    const css = styleBlock.textContent || '';
    const newCss = await rewriteCssUrlsAsync(css, toDataURL);
    styleBlock.textContent = newCss;
  }

  return dom.serialize();
}

async function rewriteCssUrlsAsync(css: string, toDataURL: (ref: string) => Promise<string>): Promise<string> {
  const urlRegex = /url\(\s*(?:'([^']+)'|"([^"]+)"|([^'")]+))\s*\)/gi;
  const matches = Array.from(css.matchAll(urlRegex));
  
  let result = css;
  for (const match of matches) {
    const [fullMatch, s1, s2, s3] = match;
    const raw = s1 || s2 || s3 || '';
    const trimmed = raw.trim();
    
    if (trimmed && !/^(data:|https?:|mailto:|javascript:)/i.test(trimmed)) {
      const newUrl = await toDataURL(trimmed);
      result = result.replace(fullMatch, `url(${newUrl})`);
    }
  }
  
  return result;
}

function getMimeType(ext: string): string {
  const mimeTypes: { [key: string]: string } = {
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.gif': 'image/gif',
    '.webp': 'image/webp',
    '.bmp': 'image/bmp',
    '.svg': 'image/svg+xml',
    '.ico': 'image/x-icon',
    '.css': 'text/css',
    '.js': 'application/javascript',
    '.txt': 'text/plain',
    '.html': 'text/html',
    '.htm': 'text/html',
    '.woff': 'font/woff',
    '.woff2': 'font/woff2',
  };
  return mimeTypes[ext.toLowerCase()] || 'application/octet-stream';
}

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const fileId = searchParams.get("fileId") || "";
    const fileUrl = searchParams.get("fileUrl") || "";
    const processAssets = (searchParams.get("processAssets") || "false") === "true";
    const uploadId = searchParams.get("uploadId") || ""; 

    if (!fileId) {
      return NextResponse.json({ error: "fileId required" }, { status: 400 });
    }

    const decoded = decodeURIComponent(fileUrl);
    const inferredName = decoded.split("/").filter(Boolean).slice(-1)[0] || "index.html";

    const absPath = await getFilePath(fileId, inferredName);
    const html = await (await import("fs/promises")).readFile(absPath, "utf8");

    if (!processAssets) {
      return new NextResponse(html, {
        status: 200,
        headers: { "Content-Type": "text/html; charset=utf-8" },
      });
    }

    const origin = process.env.NEXT_PUBLIC_BASE_PATH
      ? new URL(process.env.NEXT_PUBLIC_BASE_PATH, req.url).toString().replace(/\/$/, "")
      : new URL(req.url).origin;

    const base = `${origin}/api/files/${encodeURIComponent(fileId)}/`;

    let assetMapping = undefined;
    if (uploadId) {
      assetMapping = getAssetMapping(uploadId);
    }


    const rewritten = await rewriteHtmlAssetsWithUploadIndex(html, base, assetMapping, uploadId, fileId);

    return new NextResponse(rewritten, {
      status: 200,
      headers: { "Content-Type": "text/html; charset=utf-8" },
    });
  } catch (e) {
    return NextResponse.json(
      { error: "failed to load content", detail: e instanceof Error ? e.message : String(e) },
      { status: 500 }
    );
  }
}

// app/api/upload-zip/route.ts - UPDATED
// Now creates and stores UploadAssetIndex after ZIP extraction for cross-fileId asset resolution

import { NextResponse } from 'next/server';
import { detectFileType } from '@/lib/security/fileType';
import { previewZipCentralDirectory } from '@/lib/zipPreview';
import { processZipBuffer } from '@/lib/zip';
import { extractEncryptedZipBuffer } from '@/lib/zipPassword';
import { sendToLoggingService } from '@/lib/logging';
import { rateLimit } from '@/lib/rateLimit';
import { progressStart, progressUpdate, progressDone, progressError } from '@/lib/progressStore';
import { createUploadAssetIndex, storeUploadAssetIndex } from '@/lib/uploadAssetIndex';

const ALLOW = new Set([
  'image/png','image/jpeg','image/gif','image/webp','image/svg+xml',
  'text/html','application/pdf',
]);
const MAX_FILES = Number(process.env.ZIP_MAX_FILES ?? 200);
const MAX_TOTAL = Number(process.env.ZIP_MAX_TOTAL ?? 300 * 1024 * 1024);
const MAX_DEPTH = Number(process.env.ZIP_MAX_DEPTH ?? 2);
const PER_FILE_MAX = Number(process.env.ZIP_PER_FILE_MAX ?? 50 * 1024 * 1024);
const ENABLE_SCAN = process.env.ENABLE_VIRUS_SCAN === '1';
const ENCRYPTED_POLICY: 'skip' | 'error' | 'attempt' = (process.env.ZIP_ENCRYPTED_POLICY as 'skip' | 'error' | 'attempt') ?? 'skip';

export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const ip = (req.headers.get('x-forwarded-for') || '').split(',')[0].trim() || 'unknown-ip';
  if (!rateLimit(`zip:${ip}`, { capacity: 10, refillPerSec: 0.2 })) {
    return NextResponse.json({ error: 'Rate limit exceeded' }, { status: 429 });
  }

  const form = await req.formData();
  let file = (form.get('file') || form.get('zip')) as File | null;
  if (!file) return NextResponse.json({ error: 'No file' }, { status: 400 });

  const uploadId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  progressStart(uploadId, { name: file.name, size: file.size });
  
  try {
    progressUpdate(uploadId, 1, 'reading');

    const ab = await file.arrayBuffer();
    const buf = Buffer.from(ab);

    const head = await detectFileType(buf, file.name);
    if (head.mime !== 'application/zip') {
      progressError(uploadId, 'Not a ZIP', 0);
      return NextResponse.json({ error: 'Not a ZIP archive' }, { status: 415 });
    }

    progressUpdate(uploadId, 5, 'previewing');
    const preview = previewZipCentralDirectory(buf);
    if (!preview) {
      progressError(uploadId, 'EOCD not found', 5);
      return NextResponse.json({ error: 'Failed to parse ZIP (EOCD not found)' }, { status: 422 });
    }

    const encryptedEntries = preview.entries.filter(e => e.encrypted && !e.isDirectory);
    const hasEncrypted = encryptedEntries.length > 0;
    const compression = {
      totalCompressedBytes: preview.totals.compressed,
      totalUncompressedBytes: preview.totals.uncompressed,
      overallCompressionRatio: preview.totals.overallRatio,
      entryCount: preview.totals.files + preview.totals.dirs,
      highExpansionEntries: preview.suspicious.highExpansionEntries,
      highOverallExpansion: preview.suspicious.highOverallExpansion,
    };

    const extracted: Array<{
      fileId: string;
      fileName: string;
      fileUrl: string;
      fileSize: number;
      fileType: string;
      hash: string;
      depth: number;
      encrypted?: boolean;
    }> = [];
    const skipped: Array<{
      path?: string;
      reason: string;
    }> = [];

    
    const password = req.headers.get('x-zip-password') || undefined;
    if (hasEncrypted) {
      if (ENCRYPTED_POLICY === 'error') {
        progressError(uploadId, 'Encrypted entries present', 10);
        return NextResponse.json({
          error: 'ZIP contains password-protected entries',
          encryptedEntries: encryptedEntries.map(e => e.name),
          compression, uploadId
        }, { status: 422 });
      }
      if (ENCRYPTED_POLICY === 'attempt' && password) {
        progressUpdate(uploadId, 12, 'decrypting encrypted entries');
        const dec = await extractEncryptedZipBuffer(buf, password, {
          allow: ALLOW, 
          enableVirusScan: ENABLE_SCAN, 
          perFileMaxBytes: PER_FILE_MAX,
          prioritizeHtml: true 
        });
        extracted.push(...dec.extracted);
        skipped.push(...dec.skipped);
      } else if (ENCRYPTED_POLICY === 'skip') {
        skipped.push(...encryptedEntries.map(e => ({ path: e.name, reason: 'encrypted' })));
      }
    }

    progressUpdate(uploadId, 15, 'extracting safe entries');
    const safe = await processZipBuffer(buf, {
      allow: ALLOW,
      maxFiles: MAX_FILES,
      maxTotalBytes: MAX_TOTAL,
      maxDepth: MAX_DEPTH,
      perFileMaxBytes: PER_FILE_MAX,
      enableVirusScan: ENABLE_SCAN,
      dedup: true,
      prioritizeHtml: true, 
      
      onEntry: ({ path, index, total }) => {
        if (index % 5 === 0) progressUpdate(uploadId, Math.min(90, Math.round(15 + (index / Math.max(1, total)) * 70)), `processing: ${path}`);
      },
      onProgress: (pct) => progressUpdate(uploadId, Math.min(95, pct), 'processing')
    });

    extracted.push(...safe.extracted);
    skipped.push(...safe.skipped);

    progressUpdate(uploadId, 97, 'finalizing');

    const assetIndex = createUploadAssetIndex(extracted.map(f => ({
      fileId: f.fileId,
      fileName: f.fileName,
      fileSize: f.fileSize,
      fileType: f.fileType,
      originalPath: f.fileName 
    })));
    storeUploadAssetIndex(uploadId, assetIndex);
    
    await sendToLoggingService({
      event: 'zip-complete',
      uploadId, extractedCount: extracted.length, skippedCount: skipped.length, totals: compression
    });

    progressDone(uploadId, { extractedCount: extracted.length, skippedCount: skipped.length });
    return NextResponse.json({
      uploadId, preview, compression,
      files: extracted.map(f => f.fileName),
      extractedFiles: extracted, skipped, totalBytes: safe.totalBytes
    });
  } catch (e) {
    progressError(uploadId, (e as Error).message || 'unknown', 0);
    return NextResponse.json({ error: 'ZIP processing failed', detail: (e as Error).message, uploadId }, { status: 500 });
  }
}

// components/modals/SingleCreativeView.tsx - UPDATED
// Now prefers embeddedHtml from ZIP analyzer before falling back to API fetch

// Function to fetch HTML content from uploaded file
const fetchHtmlContent = React.useCallback(async () => {
  try {
    console.log("Fetching HTML content from:", creative.url);
    console.log("Creative type:", creative.type);
    console.log("Creative name:", creative.name);
    console.log("Creative ID:", creative.id);
    
    // Fix 1: Prefer embeddedHtml if available (from ZIP analyzer)
    if ((creative as any).embeddedHtml && (creative as any).embeddedHtml.length > 0) {
      console.log("Using embeddedHtml from ZIP analyzer, length:", (creative as any).embeddedHtml.length);
      setHtmlContent((creative as any).embeddedHtml);
      return;
    }
    
    // First, try to get the file content from our API endpoint with asset processing
    console.log("Trying API endpoint with asset processing...");
    const encodedFileUrl = encodeURIComponent(creative.url);
    
    // Build the API URL with uploadId if available
    let apiUrl = `${API_ENDPOINTS.GET_FILE_CONTENT}?fileId=${creative.id}&fileUrl=${encodedFileUrl}&processAssets=true`;
    if (creative.uploadId) {
      apiUrl += `&uploadId=${encodeURIComponent(creative.uploadId)}`;
    }
    
    const apiResponse = await fetch(apiUrl, {
      method: "GET",
      headers: {
        Accept:
          "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
      },
    });
    
    if (apiResponse.ok) {
      const htmlText = await apiResponse.text();
      console.log("HTML content loaded via API, length:", htmlText.length);
      console.log("First 200 characters:", htmlText.substring(0, 200));
      setHtmlContent(htmlText);
      return;
    } else {
      console.log("API response not OK, status:", apiResponse.status);
      const errorText = await apiResponse.text();
      console.log("API error response:", errorText);
    }
    
    // If API fails, try to fetch directly from the uploaded URL
    console.log("API failed, trying direct URL fetch...");
    const directResponse = await fetch(creative.url, {
      method: "GET",
      headers: {
        Accept:
          "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
      },
      mode: "cors",
    });
    
    console.log("Direct response status:", directResponse.status);
    
    if (directResponse.ok) {
      const htmlText = await directResponse.text();
      console.log("HTML content loaded directly, length:", htmlText.length);
      console.log("First 200 characters:", htmlText.substring(0, 200));
      setHtmlContent(htmlText);
    } else {
      // Final fallback
      console.log("All methods failed, using fallback content");
      await tryAlternativeHtmlLoading();
    }
  } catch (error) {
    console.log("Fetch error, trying alternative approach...");
    console.error("Error details:", error);
    // Try alternative approach
    await tryAlternativeHtmlLoading();
  }
}, [creative.url, creative.type, creative.name, creative.id, creative.uploadId]);

// components/modals/MultipleCreativeView.tsx - UPDATED
// Now prefers embeddedHtml from ZIP analyzer before falling back to API fetch

// Function to fetch HTML content from uploaded file
const fetchHtmlContent = async () => {
  if (!currentCreative) return;

  try {
    console.log("Fetching HTML content from:", currentCreative.url);

    // Fix 1: Prefer embeddedHtml if available (from ZIP analyzer)
    if ((currentCreative as any).embeddedHtml && (currentCreative as any).embeddedHtml.length > 0) {
      console.log("Using embeddedHtml from ZIP analyzer, length:", (currentCreative as any).embeddedHtml.length);
      setHtmlContent((currentCreative as any).embeddedHtml);
      return;
    }

    // First, try to get the file content from our API endpoint
    const encodedFileUrl = encodeURIComponent(currentCreative.url);
    
    // Build the API URL with uploadId if available
    let apiUrl = `/api/get-file-content?fileId=${currentCreative.id}&fileUrl=${encodedFileUrl}&processAssets=true`;
    if (currentCreative.uploadId) {
      apiUrl += `&uploadId=${encodeURIComponent(currentCreative.uploadId)}`;
    }
    
    const apiResponse = await fetch(apiUrl, {
      method: "GET",
      headers: {
        Accept:
          "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
      },
    });

    if (apiResponse.ok) {
      const htmlText = await apiResponse.text();
      console.log("HTML content loaded via API, length:", htmlText.length);
      setHtmlContent(htmlText);
      return;
    } else {
      console.log("API response not OK, status:", apiResponse.status);
    }

    // If API fails, try to fetch directly from the uploaded URL
    console.log("API failed, trying direct URL fetch...");
    const directResponse = await fetch(currentCreative.url, {
      method: "GET",
      headers: {
        Accept:
          "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
      },
      mode: "cors",
    });

    if (directResponse.ok) {
      const htmlText = await directResponse.text();
      console.log("HTML content loaded directly, length:", htmlText.length);
      setHtmlContent(htmlText);
    } else {
      // Final fallback
      console.log("All methods failed, using fallback content");
      setHtmlContent(`<!-- HTML Content Loading Failed -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Creative Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
        }
        .message {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #ff6b6b;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="message">
        <h3>⚠️ Unable to load original HTML content</h3>
        <p>You can start editing by replacing this content with your HTML code.</p>
    </div>
</body>
</html>`);
    }
  } catch (error) {
    console.log("Fetch error, using fallback content...");
    console.error("Error details:", error);
    setHtmlContent(`<!-- HTML Content Loading Failed -->
<!DOCTYPE html>
<html>
<body>
    <div style="padding: 20px; font-family: Arial, sans-serif;">
        <h3>⚠️ Unable to load HTML content</h3>
        <p>Please try refreshing or contact support.</p>
    </div>
</body>
</html>`);
  }
};

=== END OF LATEST UPDATES ===

