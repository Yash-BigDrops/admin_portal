# COMPLETE CODEBASE - Creative System Publisher Form
# This file contains all TypeScript (.ts) and JavaScript (.js) files from the project

================================================================================
CONFIGURATION FILES
================================================================================

next.config.ts
================================================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

================================================================================
next-env.d.ts
================================================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

================================================================================
DATABASE & CORE LIBRARIES
================================================================================

lib/db.ts
================================================================================
import { Pool } from 'pg';

if (!process.env.DATABASE_URL) {
  throw new Error(
    'DATABASE_URL environment variable is not set. ' +
    'Please configure it in your Vercel environment variables or .env.local file.'
  );
}

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: false
  },
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

pool.on('connect', () => {
});

pool.on('error', (err) => {
  console.error('❌ Database connection error:', err);
});

const initializeDatabase = async () => {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS telegram_users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(255) UNIQUE NOT NULL,
        chat_id BIGINT NOT NULL,
        first_name VARCHAR(255),
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
  } catch (error) {
    console.error('❌ Database initialization error:', error);
  }
};

initializeDatabase();

export { pool };

================================================================================
lib/utils.ts
================================================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================================================================================
lib/emailService.ts
================================================================================
import * as nodemailer from 'nodemailer';

if (!process.env.SMTP_HOST || !process.env.SMTP_PORT || !process.env.SMTP_USER || !process.env.SMTP_PASS) {
  throw new Error(
    'SMTP configuration incomplete. Please set SMTP_HOST, SMTP_PORT, SMTP_USER, and SMTP_PASS environment variables.'
  );
}

const emailConfig = {
  host: process.env.SMTP_HOST,
  port: parseInt(process.env.SMTP_PORT),
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
};

const transporter = nodemailer.createTransport(emailConfig);

export const createSubmissionEmail = (data: {
  contactName: string;
  priority: string;
  trackingLink: string;
}) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Submission Confirmation</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: #3b82f6; color: white; padding: 20px; text-align: center; }
        .content { padding: 20px; background: #f9fafb; }
        .tracking-link { background: #e0e7ff; padding: 15px; border-radius: 8px; margin: 20px 0; }
        .footer { text-align: center; padding: 20px; color: #6b7280; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Submission Confirmed!</h1>
        </div>
        <div class="content">
          <p>Hello ${data.contactName},</p>
          <p>Thank you for your submission! We have received your creative and it is now being processed.</p>
          <p><strong>Priority Level:</strong> ${data.priority}</p>
          <div class="tracking-link">
            <strong>Your Tracking Link:</strong><br>
            <a href="${data.trackingLink}" style="color: #3b82f6;">${data.trackingLink}</a>
          </div>
          <p>You can use this link to track the status of your submission.</p>
          <p>If you have any questions, please don't hesitate to contact us.</p>
          <p>Best regards,<br>Big Drops Marketing Team</p>
        </div>
        <div class="footer">
          <p>This is an automated message. Please do not reply to this email.</p>
        </div>
      </div>
    </body>
    </html>
  `;
};

export const sendEmail = async (options: {
  to: string;
  subject: string;
  html: string;
}) => {
  try {
    const mailOptions = {
      from: `"Big Drops Marketing" <${process.env.SMTP_USER}>`,
      to: options.to,
      subject: options.subject,
      html: options.html,
    };

    const info = await transporter.sendMail(mailOptions);
    return { success: true, messageId: info.messageId };
  } catch (error) {
    console.error('Email sending failed:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
};

export const verifySMTPConnection = async () => {
  try {
    await transporter.verify();
    return true;
  } catch (error) {
    return false;
  }
};

================================================================================
lib/ocrHelpers.ts
================================================================================
import Tesseract from "tesseract.js";

type UploadedFile = {
  file: File;
  previewUrl: string | null;
  originalUrl?: string;
  zipImages?: string[];
  currentImageIndex?: number;
  isHtml?: boolean;
  extractedContent?: string;
};

export type OCRWord = { text: string; bbox: { x0: number; y0: number; x1: number; y1: number } };
export type OCRResult = { text: string; words: OCRWord[]; width: number; height: number };

// Tesseract result types
type TesseractWord = { text: string; bbox: { x0: number; y0: number; x1: number; y1: number } };
type TesseractResult = { 
  text: string; 
  words?: TesseractWord[]; 
  imageDims?: { width: number; height: number };
  lines?: Array<{ baseline?: { x1: number } }>;
};

export async function extractCreativeText(
  uploadedFiles: UploadedFile[]
): Promise<string> {
  const result = await extractCreativeWithBoxes(uploadedFiles);
  return result.text;
}

export async function extractCreativeWithBoxes(
  uploadedFiles: UploadedFile[]
): Promise<OCRResult> {
  if (uploadedFiles.length === 0) return { text: "", words: [], width: 0, height: 0 };

  const file = uploadedFiles[0];

  console.log("Extracting text from file:", {
    name: file.file?.name || 'Unknown',
    type: file.file?.type || 'Unknown',
    size: file.file?.size ? `${(file.file.size / 1024 / 1024).toFixed(2)} MB` : 'Unknown',
    isHtml: file.isHtml || false,
    hasPreviewUrl: !!file.previewUrl,
    hasExtractedContent: !!file.extractedContent,
  });

  if (file.isHtml && file.previewUrl) {
    try {
      const response = await fetch(file.previewUrl);
      const html = await response.text();

      const imgMatch = html.match(/<img[^>]+src=["']([^"']+)["']/i);
      const imageUrl = imgMatch?.[1];

      if (imageUrl && imageUrl.startsWith("http")) {
        const ocrResult = await Tesseract.recognize(imageUrl, "eng", {
          logger: (m) => console.log("OCR progress:", m.status),
        });
        const ocrText = ocrResult.data.text.trim();
        if (ocrText.length > 0) {
          return { text: ocrText, words: [], width: 0, height: 0 };
        }
      }

      const cleanedText = html
        .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
        .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
        .replace(/<!--[\s\S]*?-->/g, '')
        .replace(/<br\s*\/?>/gi, '\n')
        .replace(/<\/p>/gi, '\n')
        .replace(/<\/div>/gi, '\n')
        .replace(/<\/h[1-6]>/gi, '\n')
        .replace(/<[^>]+>/g, '')
        .replace(/\s+/g, ' ')
        .replace(/\n\s*\n/g, '\n')
        .trim();

      return { text: cleanedText, words: [], width: 0, height: 0 };

    } catch (error) {
      console.error("❌ Error processing HTML preview for OCR:", error);
      return { text: "", words: [], width: 0, height: 0 };
    }
  }

  if (file.file && file.file.type.startsWith("image/")) {
    try {
      if (file.file.size < 1024 || file.file.size > 50 * 1024 * 1024) {
        return { text: "", words: [], width: 0, height: 0 };
      }

      if (file.previewUrl) {
        const result = await Tesseract.recognize(file.previewUrl, "eng", {
          logger: (m) => console.log("OCR:", m.status)
        });
        const extractedText = result.data.text || "";
        const tesseractData = result.data as TesseractResult;
        const words = tesseractData.words?.map((w) => ({
          text: w.text,
          bbox: { x0: w.bbox.x0, y0: w.bbox.y0, x1: w.bbox.x1, y1: w.bbox.y1 }
        })) || [];
        const width = tesseractData.imageDims?.width ?? tesseractData.lines?.[0]?.baseline?.x1 ?? 0;
        const height = tesseractData.imageDims?.height ?? 0;
        return { text: extractedText, words, width, height };
      }

      const result = await Tesseract.recognize(file.file, "eng", {
        logger: (m) => console.log("OCR:", m.status),
      });
      const extractedText = result.data.text || "";
      const tesseractData = result.data as TesseractResult;
      const words = tesseractData.words?.map((w) => ({
        text: w.text,
        bbox: { x0: w.bbox.x0, y0: w.bbox.y0, x1: w.bbox.x1, y1: w.bbox.y1 }
      })) || [];
      const width = tesseractData.imageDims?.width ?? tesseractData.lines?.[0]?.baseline?.x1 ?? 0;
      const height = tesseractData.imageDims?.height ?? 0;
      return { text: extractedText, words, width, height };
    } catch (error) {
      console.error("❌ Error extracting text from image:", error);
      return { text: "", words: [], width: 0, height: 0 };
    }
  }

  if (file.extractedContent) {
    return { text: file.extractedContent, words: [], width: 0, height: 0 };
  }

  return { text: "", words: [], width: 0, height: 0 };
}

================================================================================
lib/uploadHelpers.ts
================================================================================
import imageCompression from "browser-image-compression";

export async function uploadToBlob(file: File) {
  try {
    const formData = new FormData();
    formData.append("file", file);

    const response = await fetch("/api/upload-url", {
      method: "POST",
      body: formData,
    });

    if (!response.ok) {
      throw new Error("Failed to upload file");
    }

    const { url } = await response.json();
    return url;
  } catch (error) {
    console.error("Upload error:", error);
    throw new Error("Failed to upload file");
  }
}

export async function createCompressedPreview(file: File) {
  const options = {
    maxSizeMB: 0.3,
    maxWidthOrHeight: 1000,
    useWebWorker: true,
  };
  return await imageCompression(file, options);
}

================================================================================
SERVICES & API LAYER
================================================================================

services/api.ts
================================================================================
import { CreativeFormData, MultiCreative, TelegramCheckResponse } from "@/types/creative";

export const fetchOffers = async (): Promise<string[]> => {
  try {
    const response = await fetch("/api/offers");
    if (!response.ok) throw new Error("Failed to fetch offers");
    return await response.json();
  } catch (error) {
    console.error("Error fetching offers:", error);
    return [];
  }
};

export const checkTelegramUser = async (username: string): Promise<TelegramCheckResponse> => {
  try {
    const res = await fetch("/api/check-telegram-start", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username })
    });
    return await res.json();
  } catch (error) {
    console.error("Telegram check failed", error);
    return { started: false, message: "Failed to check Telegram user" };
  }
};

export const getClaudeSuggestions = async (data: {
  companyName: string;
  offerId: string;
  creativeType: string;
  notes: string;
  creativeContent: string;
  creativeFileName?: string;
  creativeIndex?: number;
  timestamp?: string;
}): Promise<{ suggestions?: string }> => {
  try {
    const res = await fetch('/api/claude', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });

    if (!res.ok) {
      const errorData = await res.json().catch(() => ({}));
      throw new Error(errorData.error || `HTTP ${res.status}: ${res.statusText}`);
    }

    return await res.json();
  } catch (error) {
    console.error('AI suggestion error:', error);
    throw error;
  }
};

export const saveCreative = async (creativeData: {
  offerId: string;
  creativeType: string;
  fromLine: string;
  subjectLines: string;
  notes: string;
  fileUrl: string;
}): Promise<void> => {
  const res = await fetch("/api/creative/save", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(creativeData),
  });

  if (!res.ok) {
    throw new Error("Failed to save creative");
  }
};

export const saveMultipleCreatives = async (creativeData: {
  offerId: string;
  creativeType: string;
  fromLine: string;
  subjectLines: string;
  multiCreatives: MultiCreative[];
  fileUrl: string;
}): Promise<void> => {
  const res = await fetch("/api/creative/save", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(creativeData),
  });

  if (!res.ok) {
    throw new Error("Failed to save creatives");
  }
};

export const deleteCreative = async (fileUrl: string): Promise<void> => {
  await fetch(`/api/creative/delete`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ fileUrl }),
  });
};

// Removed submitForm - now handled by /api/submissions endpoint
// The form submission logic is now in the useCreativeForm hook 

export type ProofreadResult = {
  corrected: string;
  edits: Array<{ 
    start: number; 
    end: number; 
    original: string; 
    suggestion: string; 
    reason: string; 
    severity: "minor" | "major" 
  }>;
};

export const proofreadText = async (text: string): Promise<ProofreadResult> => {
  const res = await fetch("/api/proofread", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text }),
  });

  if (!res.ok) {
    const err = await res.json().catch(() => ({} as any));
    throw new Error(err.error || `Proofread failed (${res.status})`);
  }
  return await res.json();
};

================================================================================
TYPES & CONSTANTS
================================================================================

types/creative.ts
================================================================================
export type UploadedFile = { 
  file?: File; 
  previewUrl: string | null;
  originalUrl?: string;
  zipImages?: string[];
  currentImageIndex?: number;
  isHtml?: boolean;
  displayName?: string;
  htmlContent?: string;
};

export type ExtractedCreative = {
  type: "image" | "html";
  url: string;
  htmlContent?: string;
};

export type MultiCreative = {
  id: number;
  imageUrl: string;
  fromLine: string;
  subjectLine: string;
  notes: string;
  type?: "image" | "html";
  htmlContent?: string;
  fileName?: string;
};

export type CreativeFormData = {
  affiliateId: string;
  companyName: string;
  firstName: string;
  lastName: string;
  contactEmail: string;
  telegramId: string;
  offerId: string;
  creativeType: string;
  fromLine: string;
  subjectLines: string;
  otherRequest: string;
};

export type TelegramCheckStatus = "unchecked" | "checking" | "ok" | "not_started";

export type TelegramCheckResponse = {
  started: boolean;
  message?: string;
};

export type Priority = "High" | "Moderate";

export type UploadType = null | "single" | "multiple";

================================================================================
constants/creative.ts
================================================================================
export const CREATIVE_TYPES = [
  "Email",
  "Display",
  "Search",
  "Social",
  "Native",
  "Push",
] as const;

export const ACCEPTED_IMAGE_EXTENSIONS = [".jpg", ".jpeg", ".png", ".gif", ".webp"];

export const ACCEPTED_FILE_TYPES = ".png,.jpg,.jpeg,.html,.zip";

export const MAX_ZIP_DEPTH = 2;

export const RESPONSIVE_STYLE = `
  <style>
    body {
      margin: 0 !important;
      padding: 10px !important;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
      background-color: #f9fafb !important;
    }
    * {
      max-width: 100% !important;
      box-sizing: border-box !important;
    }
    img {
      max-width: 100% !important;
      height: auto !important;
      display: block !important;
    }
    iframe {
      max-width: 100% !important;
    }
    .bg {
      height: auto !important;
      width: 100% !important;
      max-width: 600px !important;
    }
  </style>
`;

export const DEFAULT_HTML_TEMPLATE = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body></body></html>`;

export const TELEGRAM_BOT_URL = "https://t.me/BigDropsMarketingBot?start=from_web_form";

export const FORM_STEPS = {
  PERSONAL_DETAILS: 1,
  CONTACT_DETAILS: 2,
  CREATIVE_DETAILS: 3,
} as const;

export const STEP_LABELS = {
  1: "Personal Details",
  2: "Contact Details", 
  3: "Creative Details",
} as const;

================================================================================
UTILITIES & HOOKS
================================================================================

utils/validation.ts
================================================================================
import { CreativeFormData } from "@/types/creative";

export interface ValidationErrors {
  [key: string]: string;
}

export const validateStep1 = (formData: CreativeFormData): ValidationErrors => {
  const errors: ValidationErrors = {};

  if (!formData.affiliateId.trim()) {
    errors.affiliateId = "Please enter your Affiliate ID";
  }
  
  if (!formData.companyName.trim()) {
    errors.companyName = "Please enter your Company Name";
  }
  
  if (!formData.firstName.trim()) {
    errors.firstName = "Please enter your First Name";
  } else if (!/^[A-Za-z\s]+$/.test(formData.firstName.trim())) {
    errors.firstName = "First Name can only contain letters and spaces";
  }
  
  if (!formData.lastName.trim()) {
    errors.lastName = "Please enter your Last Name";
  } else if (!/^[A-Za-z\s]+$/.test(formData.lastName.trim())) {
    errors.lastName = "Last Name can only contain letters and spaces";
  }

  return errors;
};

export const validateStep2 = (formData: CreativeFormData): ValidationErrors => {
  const errors: ValidationErrors = {};

  if (!formData.contactEmail.trim()) {
    errors.contactEmail = "Please enter your Email ID";
  } else if (!/\S+@\S+\.\S+/.test(formData.contactEmail)) {
    errors.contactEmail = "Please enter a valid email address";
  }

  return errors;
};

export const validateStep3 = (formData: CreativeFormData): ValidationErrors => {
  const errors: ValidationErrors = {};

  if (!formData.offerId.trim()) {
    errors.offerId = "Please enter an Offer ID";
  }
  
  if (!formData.creativeType.trim()) {
    errors.creativeType = "Please enter a Creative Type";
  }

  return errors;
};

export const validateFormData = (formData: CreativeFormData, step: number): ValidationErrors => {
  switch (step) {
    case 1:
      return validateStep1(formData);
    case 2:
      return validateStep2(formData);
    case 3:
      return validateStep3(formData);
    default:
      return {};
  }
};

export const sanitizeNameInput = (value: string): string => {
  return value.replace(/[^A-Za-z\s]/g, '');
};

export const isValidEmail = (email: string): boolean => {
  return /\S+@\S+\.\S+/.test(email);
};

export const isValidName = (name: string): boolean => {
  return /^[A-Za-z\s]+$/.test(name.trim());
};

================================================================================
utils/fileUtils.ts
================================================================================
import JSZip from "jszip";
import { ExtractedCreative } from "@/types/creative";
import { ACCEPTED_IMAGE_EXTENSIONS, MAX_ZIP_DEPTH, RESPONSIVE_STYLE, DEFAULT_HTML_TEMPLATE } from "@/constants/creative";

export const isImageFile = (file: File): boolean => {
  const fileName = file.name.toLowerCase();
  if (file.type && file.type.startsWith("image/")) {
    return true;
  }
  return ACCEPTED_IMAGE_EXTENSIONS.some((ext) => fileName.endsWith(ext));
};

export const normalizePath = (p: string) => p.replace(/\\/g, "/").toLowerCase();

export const formatFileSize = (bytes: number) => {
  if (bytes === 0) return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
};

const getDirectoryPath = (filePath: string): string => {
  const normalizedPath = normalizePath(filePath);
  const lastSlashIndex = normalizedPath.lastIndexOf('/');
  return lastSlashIndex > -1 ? normalizedPath.substring(0, lastSlashIndex) : '';
};

const getTopLevelDirectory = (filePath: string): string => {
  const normalizedPath = normalizePath(filePath);
  const firstSlashIndex = normalizedPath.indexOf('/');
  return firstSlashIndex > -1 ? normalizedPath.substring(0, firstSlashIndex) : '';
};

const isInRootDirectory = (filePath: string): boolean => {
  const normalizedPath = normalizePath(filePath);
  return !normalizedPath.includes('/');
};

const directoryOrParentHasHTML = (filePath: string, allFiles: string[]): boolean => {
  const normalizedPath = normalizePath(filePath);
  const pathParts = normalizedPath.split('/');
  
  for (let i = pathParts.length - 1; i >= 0; i--) {
    const currentDirPath = pathParts.slice(0, i).join('/');
    
    const hasHTMLInThisLevel = allFiles.some(file => {
      const fileDir = getDirectoryPath(file);
      const fileName = normalizePath(file);
      return fileDir === currentDirPath && fileName.endsWith('.html');
    });
    
    if (hasHTMLInThisLevel) {
      return true;
    }
  }
  
  return false;
};

export async function extractCreativesFromZip(
  zipBlob: Blob,
  depth = 0
): Promise<ExtractedCreative[]> {
  if (depth > MAX_ZIP_DEPTH) return [];

  const jszip = new JSZip();
  const zipData = await jszip.loadAsync(zipBlob);
  let creatives: ExtractedCreative[] = [];
  
  console.log(`📦 ZIP contains ${Object.keys(zipData.files).length} files:`);
  const allFiles = Object.keys(zipData.files).filter(path => !zipData.files[path].dir);
  allFiles.forEach(file => {
    console.log(`  - ${file}`);
  });
  
  const creativeGroups = new Map<string, string[]>();
  const rootFiles: string[] = [];
  
  allFiles.forEach(filePath => {
    if (isInRootDirectory(filePath)) {
      rootFiles.push(filePath);
    } else {
      const topLevelDir = getTopLevelDirectory(filePath);
      if (!creativeGroups.has(topLevelDir)) {
        creativeGroups.set(topLevelDir, []);
      }
      creativeGroups.get(topLevelDir)!.push(filePath);
    }
  });
  
  await processRootFiles(rootFiles, zipData, creatives);
  
  for (const [dirPath, dirFiles] of creativeGroups.entries()) {
    console.log(`📁 Processing creative group: ${dirPath} (${dirFiles.length} files)`);
    await processCreativeGroup(dirPath, dirFiles, zipData, creatives, allFiles);
  }
  
  const htmlFiles = allFiles.filter(f => normalizePath(f).endsWith('.html'));
  const imageFiles = allFiles.filter(f => /\.(png|jpg|jpeg|gif|webp)$/i.test(normalizePath(f)));
  const zipFiles = allFiles.filter(f => normalizePath(f).endsWith('.zip')); 
  return creatives;
}

async function processRootFiles(
  files: string[], 
  zipData: JSZip, 
  creatives: ExtractedCreative[]
): Promise<void> {
  const htmlFiles = files.filter(f => normalizePath(f).endsWith('.html'));
  const imageFiles = files.filter(f => /\.(png|jpg|jpeg|gif|webp)$/i.test(normalizePath(f)));
  const zipFiles = files.filter(f => normalizePath(f).endsWith('.zip'));
  
  for (const htmlPath of htmlFiles) {
    try {
      const entry = zipData.files[htmlPath];
      const htmlContent = await entry.async("string");
      const url = `data:text/html;charset=utf-8,${encodeURIComponent(htmlContent)}`;
      creatives.push({ type: "html", url, htmlContent });
    } catch (error) {
      console.error(`  ❌ Error processing HTML file ${htmlPath}:`, error);
    }
  }
  
  if (htmlFiles.length === 0) {
    for (const imagePath of imageFiles) {
      try {
        const entry = zipData.files[imagePath];
        const originalBlob = await entry.async("blob");
        const url = URL.createObjectURL(originalBlob);
        creatives.push({ type: "image", url });
      } catch (error) {
        console.error(`  ❌ Error processing image file ${imagePath}:`, error);
      }
    }
  } else {
  }
  
  for (const zipPath of zipFiles) {
    try {
      const entry = zipData.files[zipPath];
      const innerBlob = await entry.async("blob");
      const innerCreatives = await extractCreativesFromZip(innerBlob, 1);
      creatives.push(...innerCreatives);
    } catch (error) {
      console.error(`  ❌ Error processing ZIP file ${zipPath}:`, error);
    }
  }
}

async function processCreativeGroup(
  groupName: string,
  files: string[], 
  zipData: JSZip, 
  creatives: ExtractedCreative[],
  allFiles: string[]
): Promise<void> {
  const htmlFiles = files.filter(f => normalizePath(f).endsWith('.html'));
  const imageFiles = files.filter(f => /\.(png|jpg|jpeg|gif|webp)$/i.test(normalizePath(f)));
  const zipFiles = files.filter(f => normalizePath(f).endsWith('.zip'));
  
  const uniqueDirs = new Set(files.map(f => getDirectoryPath(f)));
  uniqueDirs.forEach(dir => {
    const filesInDir = files.filter(f => getDirectoryPath(f) === dir);
  });
  
  if (htmlFiles.length > 0) {
    for (const htmlPath of htmlFiles) {
      try {
        const entry = zipData.files[htmlPath];
        const htmlContent = await entry.async("string");
        
        let processedHtmlContent = await embedImagesInHTML(htmlContent, imageFiles, zipData, groupName);
        
        const url = `data:text/html;charset=utf-8,${encodeURIComponent(processedHtmlContent)}`;
        creatives.push({ type: "html", url, htmlContent: processedHtmlContent });
      } catch (error) {
        console.error(`  ❌ Error processing HTML file ${htmlPath}:`, error);
      }
    }
  } else {
    for (const imagePath of imageFiles) {
      try {
        const entry = zipData.files[imagePath];
        const originalBlob = await entry.async("blob");
        const url = URL.createObjectURL(originalBlob);
        creatives.push({ type: "image", url });
      } catch (error) {
        console.error(`  ❌ Error processing image file ${imagePath}:`, error);
      }
    }
  }
  
  for (const zipPath of zipFiles) {
    try {
      const entry = zipData.files[zipPath];
      const innerBlob = await entry.async("blob");
      const innerCreatives = await extractCreativesFromZip(innerBlob, 1);
      creatives.push(...innerCreatives);
    } catch (error) {
      console.error(`  ❌ Error processing ZIP file ${zipPath}:`, error);
    }
  }
}

async function embedImagesInHTML(
  htmlContent: string, 
  imageFiles: string[], 
  zipData: JSZip, 
  groupName: string
): Promise<string> {
  let processedHTML = htmlContent;
  
  async function blobToBase64(blob: Blob): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result as string);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  
  for (const imagePath of imageFiles) {
    try {
      const entry = zipData.files[imagePath];
      const imageBlob = await entry.async("blob");
      
      const dataUrl = await blobToBase64(imageBlob);
      
      const fileName = imagePath.split('/').pop()!;
      
      const possibleRefs = [
        fileName,
        `./${fileName}`,
        `../${fileName}`,
        imagePath,
        `images/${fileName}`,
        `./images/${fileName}`,
        `../images/${fileName}`
      ];
      
      possibleRefs.forEach(ref => {
        const escapedRef = ref.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        
        processedHTML = processedHTML.replace(
          new RegExp(`src=["']${escapedRef}["']`, 'gi'),
          `src="${dataUrl}"`
        );
        
        processedHTML = processedHTML.replace(
          new RegExp(`background-image:\\s*url\\(["']?${escapedRef}["']?\\)`, 'gi'),
          `background-image: url(${dataUrl})`
        );
      });
      
    } catch (error) {
      console.error(`    ❌ Failed to embed image ${imagePath}:`, error);
    }
  }
  
  return processedHTML;
}

function getImageMimeType(filePath: string): string {
  const extension = normalizePath(filePath).split('.').pop();
  
  switch (extension) {
    case 'jpg':
    case 'jpeg':
      return 'image/jpeg';
    case 'png':
      return 'image/png';
    case 'gif':
      return 'image/gif';
    case 'webp':
      return 'image/webp';
    case 'svg':
      return 'image/svg+xml';
    default:
      return 'image/png';
  }
}

================================================================================
hooks/useCreativeForm.ts
================================================================================
// NOTE: This is a very large file (1234 lines) containing the main form logic
// It includes form state management, file upload handling, AI integration,
// form validation, multi-creative support, Telegram integration, and ZIP processing
// 
// Due to length constraints, this file is referenced but not fully included here
// The complete file can be found at: hooks/useCreativeForm.ts

================================================================================
API ROUTES
================================================================================

app/api/offers/route.ts
================================================================================
import { NextResponse } from 'next/server';

export async function GET() {
  const EVERFLOW_API_KEY = process.env.EVERFLOW_API_KEY;

  if (!EVERFLOW_API_KEY) {
    return NextResponse.json({ error: 'Everflow API key is not configured.' }, { status: 500 });
  }

  try {
    try {
      const runnableResponse = await fetch('https://api.eflow.team/v1/affiliates/offersrunnable', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'X-Eflow-API-Key': EVERFLOW_API_KEY,
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'
        },
        cache: 'no-store',
      });

      if (runnableResponse.ok) {
        const runnableData = await runnableResponse.json();
        
        if (runnableData.offers && runnableData.offers.length > 0) {
          const offerIds = runnableData.offers
            .map((offer: { network_offer_id: string | number }) => offer.network_offer_id.toString())
            .sort((a: string, b: string) => parseInt(a, 10) - parseInt(b, 10));
          
          return NextResponse.json(offerIds);
        } else {
        }
      } else {
        const errorText = await runnableResponse.text();
      }
    } catch (error) {
    }

    try {
      const allOffersResponse = await fetch('https://api.eflow.team/v1/affiliates/alloffers', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'X-Eflow-API-Key': EVERFLOW_API_KEY,
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'
        },
        cache: 'no-store',
      });

      if (allOffersResponse.ok) {
        const allOffersData = await allOffersResponse.json();
        
        if (allOffersData.offers && allOffersData.offers.length > 0) {
          const offerIds = allOffersData.offers
            .map((offer: { network_offer_id: string | number }) => offer.network_offer_id.toString())
            .sort((a: string, b: string) => parseInt(a, 10) - parseInt(b, 10));
          
          return NextResponse.json(offerIds);
        } else {
        }
      } else {
        const errorText = await allOffersResponse.text();
      }
    } catch (error) {
    }

    try {
      const networkResponse = await fetch('https://api.eflow.team/v1/networks/offerstable?page=1&page_size=1000', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Eflow-API-Key': EVERFLOW_API_KEY,
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'
        },
        body: JSON.stringify({
          filters: {
            offer_status: "active"
          },
          sort_by: {
            column: "created",
            order: "desc"
          }
        }),
        cache: 'no-store',
      });

      if (networkResponse.ok) {
        const networkData = await networkResponse.json();
        
        const offers = networkData.offers || networkData.entries || [];
        
        if (offers && offers.length > 0) {
          const allOfferIds = offers.map((offer: { network_offer_id: string | number }) => offer.network_offer_id.toString());
          const uniqueOfferIds = [...new Set(allOfferIds)].sort((a, b) => parseInt(a as string, 10) - parseInt(b as string, 10));
          
          return NextResponse.json(uniqueOfferIds);
        } else {
        }
      } else {
        const errorText = await networkResponse.text();
      }
    } catch (error) {
    }

    return NextResponse.json([]);

  } catch (error) {
    return NextResponse.json({ error: 'An internal server error occurred.' }, { status: 500 });
  }
}

================================================================================
app/api/claude/route.ts
================================================================================
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  try {
    const { 
      companyName, 
      offerId, 
      creativeType, 
      notes, 
      creativeContent,
      creativeFileName,
      creativeIndex,
      timestamp
    } = await request.json();

    if (!companyName || !offerId) {
      return NextResponse.json({ error: 'Missing required fields: companyName and offerId are required' }, { status: 400 });
    }

    if (!process.env.CLAUDE_API_KEY) {
      return NextResponse.json({ error: 'Claude API key not configured' }, { status: 500 });
    }

    const currentTimestamp = timestamp || new Date().toISOString();
    const creativeContext = creativeFileName ? `Creative: ${creativeFileName}` : 'Creative: Unnamed';
    const indexContext = creativeIndex ? `(Index: ${creativeIndex})` : '';
    
    const prompt = `
You are an expert email marketer specializing in high-converting email campaigns.

🎯 CAMPAIGN DETAILS:
- Creative Type: ${creativeType || "N/A"}
- Creative File: ${creativeContext} ${indexContext}
- Request Time: ${currentTimestamp}
- Notes: ${notes || "None"}

📄 CREATIVE CONTENT:
"""
${creativeContent || "No meaningful content was extracted from the creative. This appears to be only footer/unsubscribe content."}
"""

⚠️ CRITICAL REQUIREMENTS:
Imagine that you are a professional copywriter, digital marketer and email marketing expert with an experience of 10+ years. I want you to perform these tasks accordingly one by one without making any errors. Don't make it sound like Artificial intelligence. I want you to write it as a human that would get most conversions. These are the details of the task - 
1. Generate suggestions that are SPECIFIC to THIS creative's content and style
2. Avoid generic, one-size-fits-all suggestions
3. Each suggestion should reflect the unique elements of this creative
4. Ensure suggestions are brand-safe and non-clickbaity
5. Make suggestions compelling and engaging for the target audience

Please suggest:
1. 15 unique, brand-safe, non-clickbaity "From" lines
2. 15 compelling, engaging "Subject" lines

Format your response EXACTLY as follows:

From Lines:
1. ...
2. ...
3. ...
4. ...
5. ...
6. ...
7. ...
8. ...
9. ...
10. ...
11. ...
12. ...
13. ...
14. ...
15. ...

Subject Lines:
1. ...
2. ...
3. ...
4. ...
5. ...
6. ...
7. ...
8. ...
9. ...
10. ...
11. ...
12. ...
13. ...
14. ...
15. ...
    `;

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'x-api-key': process.env.CLAUDE_API_KEY,
        'Content-Type': 'application/json',
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 1024,
        messages: [{ role: 'user', content: prompt }]
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      return NextResponse.json({ 
        error: `Claude API error: ${response.status} ${response.statusText}`,
        details: errorText
      }, { status: response.status });
    }

    const data = await response.json();
    
    const text = data?.content?.[0]?.text;
    if (!text) {
      return NextResponse.json({ error: 'No suggestions generated from Claude API' }, { status: 500 });
    }

    return NextResponse.json({ suggestions: text });
    
  } catch (error) {
    return NextResponse.json({ 
      error: 'Claude API request failed',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

================================================================================
app/api/check-db/route.ts
================================================================================
import { NextRequest, NextResponse } from 'next/server';
import { Pool } from 'pg';

const getPool = () => {
  if (!process.env.DATABASE_URL) {
    throw new Error('DATABASE_URL environment variable is not set');
  }
  
  return new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: {
      rejectUnauthorized: false
    }
  });
};

export async function GET() {
  try {
    const pool = getPool();
    
    const allTables = await pool.query(
      `SELECT table_name 
       FROM information_schema.tables 
       WHERE table_schema = 'public' 
       AND table_name LIKE '%telegram%'
       ORDER BY table_name`
    );
    
    const tableCheck = await pool.query(
      `SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'telegram_users'
      )`
    );
    
    const tableExists = tableCheck.rows[0]?.exists;
    
    if (!tableExists) {
      const actualTableName = allTables.rows[0]?.table_name;
      
      if (actualTableName) {
        const structure = await pool.query(
          `SELECT column_name, data_type, is_nullable
           FROM information_schema.columns
           WHERE table_name = $1
           ORDER BY ordinal_position`,
          [actualTableName]
        );
        
        let sampleData: unknown[] = [];
        try {
          if (actualTableName === 'telegram_messages') {
            const result = await pool.query(
              `SELECT * FROM telegram_messages LIMIT 10`
            );
            sampleData = result.rows;
          } else if (actualTableName === 'telegram_users') {
            const result = await pool.query(
              `SELECT * FROM telegram_users LIMIT 10`
            );
            sampleData = result.rows;
          }
        } catch (e) {
        }
        
        return NextResponse.json({
          tableExists: false,
          actualTableName: actualTableName,
          structure: structure.rows,
          sampleData: sampleData,
          allTables: allTables.rows
        });
      }
      
      return NextResponse.json({ 
        error: 'No telegram_users table found',
        tableExists: false,
        allTables: allTables.rows
      });
    }
    
    const structure = await pool.query(
      `SELECT column_name, data_type, is_nullable
       FROM information_schema.columns
       WHERE table_name = 'telegram_users'
       ORDER BY ordinal_position`
    );
    
    const users = await pool.query(
      `SELECT username, chat_id, first_name, created_at, updated_at
       FROM telegram_users
       ORDER BY created_at DESC`
    );
    
    await pool.end();
    
    return NextResponse.json({
      tableExists: true,
      structure: structure.rows,
      users: users.rows,
      userCount: users.rows.length
    });
    
  } catch (error) {
    return NextResponse.json({ 
      error: error instanceof Error ? error.message : 'Unknown error',
      tableExists: false 
    }, { status: 500 });
  }
}

================================================================================
app/api/proofread/route.ts
================================================================================
import { NextRequest, NextResponse } from "next/server";

export async function POST(req: NextRequest) {
  try {
    console.log("Proofread API called");
    console.log("API Key exists:", !!process.env.OPENAI_API_KEY);
    console.log("API Key length:", process.env.OPENAI_API_KEY?.length || 0);
    
    const { text } = await req.json();
    console.log("Text received length:", text?.length || 0);

    if (!text || !text.trim()) {
      return NextResponse.json({ error: "No text to proofread." }, { status: 400 });
    }

    const prompt = `
You are a professional copy editor with an experience of 10+ years. Review the text for:
- spelling
- grammar (subject–verb agreement, tense, punctuation)
- clarity/conciseness (light)
Return ONLY JSON:
{
  "corrected": "full corrected version",
  "edits": [
    {
      "start": <number>,    
      "end": <number>,      
      "original": "…",
      "suggestion": "…",
      "reason": "…",        
      "severity": "minor" | "major"
    }
  ]
}
Text:
"""${text}"""`;

    const res = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        temperature: 0.1,
        response_format: { type: "json_object" },
        messages: [
          { role: "system", content: "Return strict JSON only." },
          { role: "user", content: prompt },
        ],
      }),
    });

    if (!res.ok) {
      const err = await res.text();
      return NextResponse.json({ error: `OpenAI error: ${err}` }, { status: 500 });
    }

    const data = await res.json();
    const content = data.choices?.[0]?.message?.content ?? "{}";
    let parsed;
    try {
      parsed = JSON.parse(content);
    } catch {
      parsed = { corrected: "", edits: [] };
    }

    return NextResponse.json(parsed);
  } catch (e: unknown) {
    return NextResponse.json({ error: e instanceof Error ? e.message : "Unknown error" }, { status: 500 });
  }
}

================================================================================
app/api/upload-url/route.ts
================================================================================
import { NextResponse } from "next/server";
import { put } from "@vercel/blob";

export async function POST(request: Request) {
  try {
    const formData = await request.formData();
    const file = formData.get("file") as File;

    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    const timestamp = Date.now();
    const randomSuffix = Math.random().toString(36).substring(2, 8);
    const fileExtension = file.name.split('.').pop();
    const fileNameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
    const uniqueFileName = `${fileNameWithoutExt}_${timestamp}_${randomSuffix}.${fileExtension}`;

    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const { url } = await put(uniqueFileName, buffer, {
      access: "public",
      contentType: file.type,
      addRandomSuffix: false, 
    });

    return NextResponse.json({ url });
  } catch (error) {
    return NextResponse.json({ error: "Upload failed" }, { status: 500 });
  }
}

================================================================================
app/api/submissions/route.ts
================================================================================
import { NextResponse } from 'next/server';
import { Pool } from 'pg';
import { sendEmail, createSubmissionEmail } from '@/lib/emailService';

const getPool = () => {
  if (!process.env.DATABASE_URL) {
    throw new Error('DATABASE_URL environment variable is not set');
  }
  
  return new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: {
      rejectUnauthorized: false
    }
  });
};

export const dynamic = 'force-dynamic';

export async function POST(request: Request) {
  try {
    const {
      offer_id,
      priority,
      contact_method,
      contact_info,
      from_lines,
      subject_lines,
      other_request,
      creatives
    } = await request.json();

    if (!offer_id || !contact_info || !creatives || creatives.length === 0) {
      return NextResponse.json({ 
        error: 'Offer ID, contact info, and at least one creative are required.' 
      }, { status: 400 });
    }

    const pool = getPool();
    
    const submissionResult = await pool.query(
      `INSERT INTO submissions (
        offer_id, priority, contact_method, contact_info, 
        from_lines, subject_lines, other_request
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING id`,
      [offer_id, priority, contact_method, contact_info, from_lines, subject_lines, other_request]
    );

    const submissionId = submissionResult.rows[0].id;
    const trackingLink = `https://www.bigdropsmarketing.com/tracking_link/BDMG${submissionId}`;

    for (const creative of creatives) {
      await pool.query(
        `INSERT INTO creative_files (
          submission_id, file_url, file_key, original_filename, 
          creative_from_lines, creative_subject_lines, creative_notes, creative_html_code
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
        [
          submissionId, 
          creative.file_url, 
          creative.file_key, 
          creative.original_filename, 
          creative.creative_from_lines, 
          creative.creative_subject_lines, 
          creative.creative_notes, 
          creative.creative_html_code
        ]
      );
    }

    if (contact_info) {
      try {
        const emailHtml = createSubmissionEmail({
          contactName: 'there',
          priority: priority || 'Moderate',
          trackingLink,
        });
        
        const emailResult = await sendEmail({
          to: contact_info,
          subject: 'Your Submission Has Been Received!',
          html: emailHtml,
        });
        
        if (emailResult.success) {
        } else {
        }
      } catch (exception) {
      }
    }

    await pool.end();
    
    return NextResponse.json({ 
      success: true, 
      submissionId,
      trackingLink 
    });

  } catch (error) {
    return NextResponse.json({ 
      error: 'Server error during submission.' 
    }, { status: 500 });
  }
}

================================================================================
app/api/telegram-webhook/route.ts
================================================================================
import { NextRequest, NextResponse } from 'next/server';
import { Pool } from 'pg';

const getPool = () => {
  if (!process.env.DATABASE_URL) {
    throw new Error('DATABASE_URL environment variable is not set');
  }
  
  return new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: {
      rejectUnauthorized: false
    }
  });
};

export async function POST(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    console.log('📥 Telegram webhook received');
    const headers = Object.fromEntries(request.headers.entries());
    console.log('📋 Headers:', Object.keys(headers));
    
    const update = await request.json();
    console.log('📨 Update received:', JSON.stringify(update, null, 2));
    
    if (update.message) {
      const msg = update.message;
      console.log('💬 Message from:', msg.from?.username || msg.from?.first_name, 'Chat ID:', msg.chat?.id);
    }
    
    if (update.message?.text?.startsWith('/start')) {
      console.log('🚀 /start command received');
      
      const chatId = update.message.chat.id;
      const username = update.message.chat.username || update.message.from?.username;
      const firstName = update.message.chat.first_name || update.message.from?.first_name;
      
      console.log('👤 User details:', { chatId, username, firstName });
      
      if (!username) {
        console.log('⚠️ No username provided');
        
        const botToken = process.env.TELEGRAM_BOT_TOKEN;
        
        if (botToken) {
          console.log('📤 Sending username requirement message');
          const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              chat_id: chatId,
              text: "⚠️ Please set a username in your Telegram profile first, then send /start again. This is required to connect your account.",
              parse_mode: "HTML"
            })
          });
          
          const responseData = await response.json();
          console.log('📤 Username requirement message response:', responseData);
          if (!responseData.ok) {
            console.log('❌ Failed to send username requirement message:', responseData.description);
          }
        } else {
          console.log('❌ TELEGRAM_BOT_TOKEN not configured');
        }
        
        return NextResponse.json({ ok: true, message: 'No username provided' });
      }
      
      console.log('💾 Saving user to database...');
      try {
        const pool = getPool();
        const result = await pool.query(
          `INSERT INTO telegram_users (username, chat_id, first_name, created_at)
           VALUES ($1, $2, $3, NOW())
           ON CONFLICT (username) 
           DO UPDATE SET 
             chat_id = EXCLUDED.chat_id,
             first_name = EXCLUDED.first_name,
             updated_at = NOW()
           RETURNING id, username, chat_id, first_name, created_at`,
          [username, chatId, firstName]
        );
        
        console.log('✅ User saved to database:', result.rows[0]);
        
        const verify = await pool.query(
          'SELECT * FROM telegram_users WHERE username = $1',
          [username]
        );
        
        const countResult = await pool.query('SELECT COUNT(*) as total FROM telegram_users');
        console.log('📊 Total users in database:', countResult.rows[0].total);
        
        await pool.end();
        
      } catch (dbError) {
        console.log('❌ Database error:', dbError);
        
        const botToken = process.env.TELEGRAM_BOT_TOKEN;
        if (botToken) {
          console.log('📤 Sending database error message');
          await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              chat_id: chatId,
              text: "❌ There was an error registering your account. Please contact support.",
              parse_mode: "HTML"
            })
          });
        }
        
        return NextResponse.json({ ok: false, error: 'Database error', details: dbError instanceof Error ? dbError.message : 'Unknown error' });
      }
      
      const botToken = process.env.TELEGRAM_BOT_TOKEN;
      
      if (botToken) {
        console.log('📤 Sending welcome message');
        try {
          const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              chat_id: chatId,
              text: "✅ Welcome! You're now connected to Big Drops Marketing notifications. You'll receive updates about your creative submissions here.",
              parse_mode: "HTML"
            })
          });
          
          const responseData = await response.json();
          console.log('📤 Welcome message response:', responseData);
          
          if (responseData.ok) {
            console.log('✅ Welcome message sent successfully');
          } else {
            console.log('❌ Failed to send welcome message:', responseData.description);
          }
          
        } catch (msgError) {
          console.log('❌ Error sending welcome message:', msgError);
        }
      } else {
        console.log('❌ TELEGRAM_BOT_TOKEN not configured');
      }
      
    } else {
      console.log('📝 Non-/start message received');
    }
    
    const processingTime = Date.now() - startTime;
    console.log('⏱️ Processing time:', processingTime + 'ms');
    
    return NextResponse.json({ ok: true, processing_time: processingTime });
    
  } catch (error) {
    const processingTime = Date.now() - startTime;
    console.log('❌ Webhook error:', error);
    
    return NextResponse.json({ 
      ok: false, 
      error: 'Webhook processing failed', 
      details: error instanceof Error ? error.message : 'Unknown error',
      processing_time: processingTime
    }, { status: 500 });
  }
}

================================================================================
app/api/test-telegram/route.ts
================================================================================
import { NextRequest, NextResponse } from 'next/server';
import { Pool } from 'pg';

const getPool = () => {
  if (!process.env.DATABASE_URL) {
    throw new Error('DATABASE_URL environment variable is not set');
  }
  
  return new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: {
      rejectUnauthorized: false
    }
  });
};

export async function POST(request: NextRequest) {
  try {
    const { username, chatId, firstName } = await request.json();
    
    if (!username || !chatId) {
      return NextResponse.json({ 
        error: 'Username and chatId are required' 
      }, { status: 400 });
    }

    const pool = getPool();
    const result = await pool.query(
      `INSERT INTO telegram_users (username, chat_id, first_name, created_at)
       VALUES ($1, $2, $3, NOW())
       ON CONFLICT (username) 
       DO UPDATE SET 
         chat_id = EXCLUDED.chat_id,
         first_name = EXCLUDED.first_name,
         updated_at = NOW()
       RETURNING username, chat_id, first_name`,
      [username, chatId, firstName || 'Test User']
    );
    
    await pool.end();
    
    return NextResponse.json({
      success: true,
      user: result.rows[0],
      message: `Test user @${username} added/updated successfully`
    });
    
  } catch (error) {
    return NextResponse.json({ 
      error: error instanceof Error ? error.message : 'Unknown error' 
    }, { status: 500 });
  }
}

================================================================================
app/api/check-telegram-start/route.ts
================================================================================
import { NextRequest, NextResponse } from 'next/server';
import { Pool } from 'pg';

const getPool = () => {
  if (!process.env.DATABASE_URL) {
    throw new Error('DATABASE_URL environment variable is not set');
  }
  
  return new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: {
      rejectUnauthorized: false
    }
  });
};

export async function POST(request: NextRequest) {
  try {
    const { username } = await request.json();
    
    if (!username) {
      return NextResponse.json({ started: false, message: "No username provided" });
    }

    const cleanUsername = username.trim().replace(/^@/, '');

    const pool = getPool();

    const tableCheck = await pool.query(
      `SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'telegram_users'
      )`
    );
    
    const tableExists = tableCheck.rows[0]?.exists;
    
    if (!tableExists) {
      await pool.end();
      return NextResponse.json({ 
        started: false, 
        message: "Database table not found. Please contact support." 
      });
    }

    const result = await pool.query(
      `SELECT chat_id, first_name 
       FROM telegram_users 
       WHERE username = $1`,
      [cleanUsername]
    );

    if (result.rows.length === 0) {
      const allUsers = await pool.query(
        `SELECT username, chat_id, first_name, created_at
         FROM telegram_users
         ORDER BY created_at DESC
         LIMIT 5`
      );
      
      await pool.end();
      return NextResponse.json({ 
        started: false, 
        message: `User @${cleanUsername} not found. Please start the bot first by sending /start to @BigDropsMarketingBot` 
      });
    }

    const user = result.rows[0];

    const botToken = process.env.TELEGRAM_BOT_TOKEN;
    if (!botToken) {
      await pool.end();
      return NextResponse.json({ started: false });
    }

    const msgRes = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        chat_id: user.chat_id,
        text: "✅ Telegram connection verified!",
        disable_notification: true
      })
    });

    const msgData = await msgRes.json();

    if (msgData.ok) {
      await pool.end();
      return NextResponse.json({ started: true, message: "Telegram connection verified successfully!" });
    } else {
      await pool.end();
      return NextResponse.json({ 
        started: false, 
        message: `Failed to send test message: ${msgData.description}` 
      });
    }

  } catch (err) {
    return NextResponse.json({ started: false });
  }
}

================================================================================
app/api/creative/save/route.ts
================================================================================
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    const data = await req.json();
    const { offerId, creativeType, fromLine, subjectLines, notes, fileUrl, multiCreatives } = data;

    if (!fileUrl) {
      return NextResponse.json({ error: "No file URL provided" }, { status: 400 });
    }

    return NextResponse.json({ 
      success: true,
      message: "Creative saved successfully",
      fileUrl: fileUrl
    });
  } catch (error) {
    return NextResponse.json({ error: "Save failed" }, { status: 500 });
  }
}

================================================================================
app/api/creative/delete/route.ts
================================================================================
import { NextResponse } from "next/server";
import { del } from "@vercel/blob";

export async function POST(req: Request) {
  try {
    const data = await req.json();
    const { fileUrl } = data;

    if (!fileUrl) {
      return NextResponse.json({ error: "No file URL provided" }, { status: 400 });
    }

    const url = new URL(fileUrl);
    const blobPath = url.pathname.substring(1);

    await del(blobPath);

    return NextResponse.json({ 
      success: true,
      message: "Creative deleted successfully"
    });
  } catch (error) {
    return NextResponse.json({ error: "Delete failed" }, { status: 500 });
  }
}

================================================================================
app/api/creative/delete-temp/route.ts
================================================================================
import { NextResponse } from "next/server";
import { del } from "@vercel/blob";

export async function DELETE(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const fileUrl = searchParams.get("fileUrl");

    if (!fileUrl) {
      return NextResponse.json({ error: "No file URL provided" }, { status: 400 });
    }

    const url = new URL(fileUrl);
    const blobPath = url.pathname.substring(1);

    await del(blobPath);

    return NextResponse.json({ success: true });
  } catch (error) {
    return NextResponse.json({ error: "Delete failed" }, { status: 500 });
  }
}

================================================================================
app/api/cron/cleanup/route.ts
================================================================================
import { del } from "@vercel/blob";
import { sql } from "@vercel/postgres";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  const authHeader = request.headers.get("authorization");
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response("Unauthorized", { status: 401 });
  }

  try {
    const fourteenDaysAgo = new Date(
      Date.now() - 14 * 24 * 60 * 60 * 1000
    ).toISOString();

    const oldSubmissions = await sql`
      SELECT id, file_key FROM submissions
      WHERE created_at < ${fourteenDaysAgo};
    `;

    if (oldSubmissions.rows.length === 0) {
      return NextResponse.json({ message: "No old files to delete." });
    }

    const keysToDelete = oldSubmissions.rows
      .map((row) => row.file_key as string)
      .filter(Boolean);
    const idsToDelete = oldSubmissions.rows.map((row) => row.id as number);

    if (keysToDelete.length > 0) {
      await del(keysToDelete);
    }

    for (const id of idsToDelete) {
      await sql`DELETE FROM submissions WHERE id = ${id}`;
    }
    return NextResponse.json({
      message: `Deleted ${idsToDelete.length} old submissions.`,
    });
  } catch (error) {
    return NextResponse.json({ error: "Cron job failed." }, { status: 500 });
  }
}

================================================================================
MAIN PAGE
================================================================================

app/page.tsx
================================================================================
import CreativeForm from "@/components/CreativeForm";

export default function HomePage() {
  return (
    <main>
      <CreativeForm />
    </main>
  );
}

================================================================================
JAVASCRIPT UTILITY FILES
================================================================================

list-tables.js
================================================================================
require('dotenv').config({ path: '.env.development.local' });
const { Pool } = require('pg');

if (!process.env.DATABASE_URL) {
  console.error('❌ DATABASE_URL environment variable is not set');
  console.error('Please set it in your .env.development.local file');
  process.exit(1);
}

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: false
  }
});

async function listAllTables() {
  try {
    
    const tablesResult = await pool.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      ORDER BY table_name
    `);
    
    if (tablesResult.rows.length === 0) {
    } else {
      tablesResult.rows.forEach((table, index) => {
        console.log(`${index + 1}. ${table.table_name}`);
      });
    }
    
    const dbResult = await pool.query('SELECT current_database() as db_name, current_user as user_name');
    console.log(`Database: ${dbResult.rows[0].db_name}`);
    console.log(`User: ${dbResult.rows[0].user_name}`);
    
  } catch (error) {
  } finally {
    await pool.end();
  }
}

listAllTables(); 

================================================================================
check-db-schema.js
================================================================================
require('dotenv').config({ path: '.env.development.local' });
const { Pool } = require('pg');

if (!process.env.DATABASE_URL) {
  console.error('❌ DATABASE_URL environment variable is not set');
  console.error('Please set it in your .env.development.local file');
  process.exit(1);
}

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: false
  }
});

async function checkAndCreateTables() {
  try {
    
    const submissionsCheck = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'submissions'
      )
    `);
        
    const creativeFilesCheck = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'creative_files'
      )
    `);
    
    const submissionsStructure = await pool.query(`
      SELECT column_name, data_type, is_nullable, column_default
      FROM information_schema.columns 
      WHERE table_name = 'submissions' 
      ORDER BY ordinal_position
    `);
    
    submissionsStructure.rows.forEach(col => {
      console.log(`  - ${col.column_name}: ${col.data_type} ${col.is_nullable === 'NO' ? 'NOT NULL' : 'NULL'} ${col.column_default ? `DEFAULT ${col.column_default}` : ''}`);
    });
    
    const creativeFilesStructure = await pool.query(`
      SELECT column_name, data_type, is_nullable, column_default
      FROM information_schema.columns 
      WHERE table_name = 'creative_files' 
      ORDER BY ordinal_position
    `);
    
    creativeFilesStructure.rows.forEach(col => {
      console.log(`  - ${col.column_name}: ${col.data_type} ${col.is_nullable === 'NO' ? 'NOT NULL' : 'NULL'} ${col.column_default ? `DEFAULT ${col.column_default}` : ''}`);
    });
    
    const submissionsCount = await pool.query('SELECT COUNT(*) as count FROM submissions');
    
    const creativeFilesCount = await pool.query('SELECT COUNT(*) as count FROM creative_files');
    
    const recentSubmissions = await pool.query(`
      SELECT id, offer_id, contact_info, from_lines, subject_lines, created_at 
      FROM submissions 
      ORDER BY created_at DESC 
      LIMIT 5
    `);
    
    if (recentSubmissions.rows.length === 0) {
    } else {
      recentSubmissions.rows.forEach((sub, index) => {
        console.log(`${index + 1}. ID: ${sub.id}, Offer: ${sub.offer_id}, Contact: ${sub.contact_info}`);
        console.log(`   From Lines: ${sub.from_lines ? 'Yes' : 'No'}, Subject Lines: ${sub.subject_lines ? 'Yes' : 'No'}`);
        console.log(`   Created: ${sub.created_at}`);
      });
    }
    
  } catch (error) {
    console.error('❌ Database schema check failed:', error);
  } finally {
    await pool.end();
  }
}

checkAndCreateTables(); 

================================================================================
db-test.js
================================================================================
require('dotenv').config({ path: '.env.development.local' });
const { Pool } = require('pg');

if (!process.env.DATABASE_URL) {
  console.error('❌ DATABASE_URL environment variable is not set');
  console.error('Please set it in your .env.development.local file');
  process.exit(1);
}

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: false
  }
});

async function testDatabase() {
  try {
    const timeResult = await pool.query('SELECT NOW() as current_time');
    const tableCheck = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'telegram_users'
      )
    `);
    
    if (!tableCheck.rows[0].exists) {
      await pool.query(`
        CREATE TABLE telegram_users (
          id SERIAL PRIMARY KEY,
          username VARCHAR(255) UNIQUE NOT NULL,
          chat_id BIGINT NOT NULL,
          first_name VARCHAR(255),
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW()
        )
      `);
    }
    
    const insertResult = await pool.query(`
      INSERT INTO telegram_users (username, chat_id, first_name, created_at)
      VALUES ($1, $2, $3, NOW())
      ON CONFLICT (username) 
      DO UPDATE SET 
        chat_id = EXCLUDED.chat_id,
        first_name = EXCLUDED.first_name,
        updated_at = NOW()
      RETURNING id, username, chat_id, first_name
    `, ['samiwasta', 123456789, 'Test User']);
    
    const selectResult = await pool.query(
      'SELECT * FROM telegram_users WHERE username = $1',
      ['samiwasta']
    );
    
    const allUsers = await pool.query(
      'SELECT username, chat_id, first_name, created_at FROM telegram_users ORDER BY created_at DESC'
    );
    
    if (allUsers.rows.length === 0) {
    } else {
      allUsers.rows.forEach((user, index) => {
        console.log(`${index + 1}. @${user.username} (${user.chat_id}) - ${user.first_name}`);
      });
    }
    
  } catch (error) {
  } finally {
    await pool.end();
  }
}

testDatabase(); 

================================================================================
test-telegram-send.js
================================================================================
require('dotenv').config({ path: '.env.development.local' });

const https = require('https');

if (!process.env.TELEGRAM_BOT_TOKEN) {
  console.error('❌ TELEGRAM_BOT_TOKEN environment variable is not set');
  console.error('Please set it in your .env.development.local file');
  process.exit(1);
}

const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;

function sendMessage(chatId, text) {
  return new Promise((resolve, reject) => {
    const data = JSON.stringify({
      chat_id: chatId,
      text: text,
      parse_mode: "HTML"
    });
    
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/sendMessage`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
      }
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.write(data);
    req.end();
  });
}

async function testSendMessage() {
  try {
    console.log('🧪 Testing Telegram message sending...');
    
    // Test with a sample chat ID (you'll need to replace this with a real chat ID)
    const testChatId = '123456789'; // Replace with actual chat ID
    const testMessage = '🧪 This is a test message from Big Drops Marketing Bot';
    
    console.log('📤 Sending test message to chat ID:', testChatId);
    const result = await sendMessage(testChatId, testMessage);
    
    if (result.ok) {
      console.log('✅ Message sent successfully!');
      console.log('📋 Message ID:', result.result.message_id);
      console.log('📅 Date:', new Date(result.result.date * 1000));
    } else {
      console.log('❌ Failed to send message:', result.description);
      console.log('🔍 Error code:', result.error_code);
    }
    
  } catch (error) {
    console.log('❌ Error sending message:', error.message);
  }
}

// Also test getting bot info
async function getBotInfo() {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/getMe`,
      method: 'GET'
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.end();
  });
}

async function runTests() {
  console.log('🤖 Testing Telegram Bot...\n');
  
  // Test 1: Get bot info
  try {
    console.log('1️⃣ Getting bot information...');
    const botInfo = await getBotInfo();
    
    if (botInfo.ok) {
      console.log('✅ Bot info retrieved successfully');
      console.log('🤖 Bot name:', botInfo.result.first_name);
      console.log('👤 Username:', botInfo.result.username);
      console.log('🆔 Bot ID:', botInfo.result.id);
      console.log('📝 Can join groups:', botInfo.result.can_join_groups);
      console.log('📢 Can read all group messages:', botInfo.result.can_read_all_group_messages);
      console.log('🔧 Supports inline queries:', botInfo.result.supports_inline_queries);
    } else {
      console.log('❌ Failed to get bot info:', botInfo.description);
    }
  } catch (error) {
    console.log('❌ Error getting bot info:', error.message);
  }
  
  console.log('\n2️⃣ Testing message sending...');
  console.log('⚠️ Note: You need to provide a valid chat ID to test message sending');
  console.log('💡 To get your chat ID:');
  console.log('   1. Send /start to your bot');
  console.log('   2. Check the webhook logs or database');
  console.log('   3. Replace the testChatId in this script\n');
  
  // Uncomment the line below and replace with actual chat ID to test
  // await testSendMessage();
}

runTests();

================================================================================
test-email-config.js
================================================================================
require('dotenv').config({ path: '.env.development.local' });

const nodemailer = require('nodemailer');

const emailConfig = {
  host: process.env.SMTP_HOST || 'smtp.gmail.com',
  port: parseInt(process.env.SMTP_PORT || '587'),
  secure: false,
  auth: {
    user: process.env.SMTP_USER || 'your-email@gmail.com',
    pass: process.env.SMTP_PASS || 'your-app-password',
  },
};

async function testEmailConfig() {
  console.log('📧 Testing Email Configuration...\n');
  
  console.log('🔧 Current SMTP Configuration:');
  console.log('   Host:', emailConfig.host);
  console.log('   Port:', emailConfig.port);
  console.log('   User:', emailConfig.auth.user);
  console.log('   Pass:', emailConfig.auth.pass ? '***' + emailConfig.auth.pass.slice(-4) : 'NOT SET');
  
  const transporter = nodemailer.createTransport(emailConfig);
  
  try {
    console.log('\n🔍 Verifying SMTP connection...');
    await transporter.verify();
    console.log('✅ SMTP connection verified successfully!');
    
    console.log('\n📤 Testing email sending...');
    const testMailOptions = {
      from: `"Big Drops Marketing Test" <${emailConfig.auth.user}>`,
      to: emailConfig.auth.user, // Send to yourself for testing
      subject: '🧪 Email Configuration Test',
      html: `
        <h2>Email Configuration Test</h2>
        <p>This is a test email to verify that your SMTP configuration is working correctly.</p>
        <p><strong>Time:</strong> ${new Date().toLocaleString()}</p>
        <p><strong>SMTP Host:</strong> ${emailConfig.host}</p>
        <p><strong>SMTP Port:</strong> ${emailConfig.port}</p>
        <p>If you receive this email, your email configuration is working! 🎉</p>
      `
    };
    
    const info = await transporter.sendMail(testMailOptions);
    console.log('✅ Test email sent successfully!');
    console.log('📋 Message ID:', info.messageId);
    console.log('📧 Email sent to:', testMailOptions.to);
    
  } catch (error) {
    console.log('❌ Email configuration error:', error.message);
    
    if (error.code === 'EAUTH') {
      console.log('\n🔧 Gmail Authentication Issues:');
      console.log('1. Enable 2-Factor Authentication on your Google account');
      console.log('2. Generate an App Password:');
      console.log('   - Go to https://myaccount.google.com/apppasswords');
      console.log('   - Select "Mail" and your device');
      console.log('   - Use the generated 16-character password');
      console.log('3. Update your .env.development.local file:');
      console.log('   SMTP_PASS="your-16-character-app-password"');
    } else if (error.code === 'ECONNECTION') {
      console.log('\n🔧 Connection Issues:');
      console.log('1. Check your internet connection');
      console.log('2. Verify SMTP_HOST and SMTP_PORT are correct');
      console.log('3. Try using port 465 with secure: true');
    }
  }
}

testEmailConfig();

================================================================================
test-real-user.js
================================================================================
require('dotenv').config({ path: '.env.development.local' });

const { Pool } = require('pg');
const https = require('https');

const getPool = () => {
  if (!process.env.DATABASE_URL) {
    throw new Error('DATABASE_URL environment variable is not set');
  }
  
  return new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: {
      rejectUnauthorized: false
    }
  });
};

const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;

function sendMessage(chatId, text) {
  return new Promise((resolve, reject) => {
    const data = JSON.stringify({
      chat_id: chatId,
      text: text,
      parse_mode: "HTML"
    });
    
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/sendMessage`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
      }
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.write(data);
    req.end();
  });
}

async function testRealUser() {
  try {
    console.log('🧪 Testing with real user...');
    
    const pool = getPool();
    
    // Get the most recently registered real user (skip the test user)
    const users = await pool.query(
      `SELECT id, username, chat_id, first_name, created_at 
       FROM telegram_users 
       WHERE username != 'testuser'
       ORDER BY created_at DESC
       LIMIT 1`
    );
    
    if (users.rows.length === 0) {
      console.log('❌ No real users found in database');
      await pool.end();
      return;
    }
    
    const user = users.rows[0];
    console.log(`👤 Testing with user: @${user.username} (Chat ID: ${user.chat_id})`);
    
    const testMessage = `🧪 Test message from Big Drops Marketing Bot

This is a test message to verify that the bot can send messages successfully.

Time: ${new Date().toLocaleString()}
User: @${user.username}

If you receive this message, the Telegram integration is working correctly! 🎉`;
    
    console.log('📤 Sending test message...');
    const result = await sendMessage(user.chat_id, testMessage);
    
    if (result.ok) {
      console.log('✅ Test message sent successfully!');
      console.log('📋 Message ID:', result.result.message_id);
      console.log('📅 Date:', new Date(result.result.date * 1000).toLocaleString());
      console.log('🎉 Telegram message sending is working correctly!');
    } else {
      console.log('❌ Failed to send test message:', result.description);
      console.log('🔍 Error code:', result.error_code);
      
      if (result.error_code === 403) {
        console.log('💡 User has blocked the bot or deleted the chat');
      } else if (result.error_code === 400) {
        console.log('💡 Invalid chat ID or bot permissions issue');
      }
    }
    
    await pool.end();
    
  } catch (error) {
    console.log('❌ Error:', error.message);
  }
}

testRealUser();

================================================================================
check-webhook-status.js
================================================================================
require('dotenv').config({ path: '.env.development.local' });

const https = require('https');

const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;

function getWebhookInfo() {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/getWebhookInfo`,
      method: 'GET'
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.end();
  });
}

async function checkWebhookStatus() {
  try {
    console.log('🔍 Checking Telegram webhook status...');
    const webhookInfo = await getWebhookInfo();
    
    if (webhookInfo.ok) {
      const info = webhookInfo.result;
      console.log('✅ Webhook info retrieved successfully');
      console.log('📋 Webhook URL:', info.url || 'Not set');
      console.log('📊 Pending updates:', info.pending_update_count);
      console.log('🔄 Last error date:', info.last_error_date);
      console.log('❌ Last error message:', info.last_error_message);
      
      if (!info.url) {
        console.log('⚠️ No webhook URL is set!');
      } else if (info.last_error_message) {
        console.log('❌ Webhook has errors:', info.last_error_message);
      } else if (info.pending_update_count > 0) {
        console.log('📥 There are pending updates to process');
      } else {
        console.log('✅ Webhook is working correctly');
      }
    } else {
      console.log('❌ Failed to get webhook info:', webhookInfo.description);
    }
    
  } catch (error) {
    console.log('❌ Error checking webhook status:', error.message);
  }
}

checkWebhookStatus(); 

================================================================================
test-webhook-simulation.js
================================================================================
require('dotenv').config({ path: '.env.development.local' });

const https = require('https');

const WEBHOOK_URL = 'https://publisher-form-nu.vercel.app/api/telegram-webhook';

// Simulate a /start message from a user
const mockUpdate = {
  update_id: 123456789,
  message: {
    message_id: 1,
    from: {
      id: 987654321,
      is_bot: false,
      first_name: "Test",
      username: "testuser",
      language_code: "en"
    },
    chat: {
      id: 987654321,
      first_name: "Test",
      username: "testuser",
      type: "private"
    },
    date: Math.floor(Date.now() / 1000),
    text: "/start"
  }
};

function sendWebhookSimulation() {
  return new Promise((resolve, reject) => {
    const data = JSON.stringify(mockUpdate);
    
    const options = {
      hostname: 'publisher-form-nu.vercel.app',
      port: 443,
      path: '/api/telegram-webhook',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length,
        'User-Agent': 'TelegramBot/1.0'
      }
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve({ status: res.statusCode, data: result });
        } catch (error) {
          resolve({ status: res.statusCode, data: responseData });
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.write(data);
    req.end();
  });
}

async function testWebhookSimulation() {
  try {
    console.log('🧪 Testing webhook simulation...');
    console.log('📤 Sending mock /start message to webhook...');
    
    const result = await sendWebhookSimulation();
    
    console.log('📥 Webhook response status:', result.status);
    console.log('📥 Webhook response data:', JSON.stringify(result.data, null, 2));
    
    if (result.status === 200) {
      console.log('✅ Webhook responded successfully');
    } else {
      console.log('❌ Webhook returned error status:', result.status);
    }
    
  } catch (error) {
    console.log('❌ Error testing webhook:', error.message);
  }
}

// Also test direct message sending
async function testDirectMessage() {
  const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
  
  // You'll need to replace this with a real chat ID
  const testChatId = '123456789'; // Replace with actual chat ID
  
  return new Promise((resolve, reject) => {
    const data = JSON.stringify({
      chat_id: testChatId,
      text: "🧪 Direct test message from Big Drops Marketing Bot\n\nThis is a direct test to verify the bot can send messages.",
      parse_mode: "HTML"
    });
    
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/sendMessage`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
      }
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve({ status: res.statusCode, data: result });
        } catch (error) {
          resolve({ status: res.statusCode, data: responseData });
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.write(data);
    req.end();
  });
}

async function runTests() {
  console.log('🤖 Testing Telegram functionality...\n');
  
  // Test 1: Webhook simulation
  console.log('1️⃣ Testing webhook simulation...');
  await testWebhookSimulation();
  
  console.log('\n2️⃣ Testing direct message sending...');
  console.log('⚠️ Note: You need to provide a valid chat ID to test direct messaging');
  console.log('💡 To get your chat ID:');
  console.log('   1. Send /start to @BigDropsMarketingBot');
  console.log('   2. Check the webhook logs');
  console.log('   3. Replace the testChatId in this script\n');
  
  // Uncomment the line below and replace with actual chat ID to test
  // const directResult = await testDirectMessage();
  // console.log('📤 Direct message result:', directResult);
}

runTests();

================================================================================
test-telegram-users.js
================================================================================
require('dotenv').config({ path: '.env.development.local' });

const { Pool } = require('pg');

const getPool = () => {
  if (!process.env.DATABASE_URL) {
    throw new Error('DATABASE_URL environment variable is not set');
  }
  
  return new Pool({
    connectionString: process.env.DATABASE_URL,
    file: 'pg',
    ssl: {
      rejectUnauthorized: false
    }
  });
};

const https = require('https');

const BOT_TOKEN = '8270513237:AAFDQKccnayiW8CiWyHLtBXjriZ8e7k4QBQ';

function sendMessage(chatId, text) {
  return new Promise((resolve, reject) => {
    const data = JSON.stringify({
      chat_id: chatId,
      text: text,
      parse_mode: "HTML"
    });
    
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/sendMessage`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
      }
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.write(data);
    req.end();
  });
}

async function checkUsersAndTestMessage() {
  try {
    console.log('🔍 Checking registered Telegram users...');
    
    const pool = getPool();
    
    // Check if table exists
    const tableCheck = await pool.query(
      `SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'telegram_users'
      )`
    );
    
    if (!tableCheck.rows[0]?.exists) {
      console.log('❌ telegram_users table does not exist');
      await pool.end();
      return;
    }
    
    // Get all users
    const users = await pool.query(
      `SELECT id, username, chat_id, first_name, created_at 
       FROM telegram_users 
       ORDER BY created_at DESC`
    );
    
    console.log(`📊 Found ${users.rows.length} registered users:`);
    
    if (users.rows.length === 0) {
      console.log('⚠️ No users registered yet. Users need to send /start to the bot first.');
      console.log('💡 To test:');
      console.log('   1. Go to @BigDropsMarketingBot on Telegram');
      console.log('   2. Send /start');
      console.log('   3. Run this script again');
    } else {
      users.rows.forEach((user, index) => {
        console.log(`\n👤 User ${index + 1}:`);
        console.log(`   ID: ${user.id}`);
        console.log(`   Username: @${user.username}`);
        console.log(`   Chat ID: ${user.chat_id}`);
        console.log(`   Name: ${user.first_name}`);
        console.log(`   Registered: ${new Date(user.created_at).toLocaleString()}`);
      });
      
      // Test sending message to the first user
      const firstUser = users.rows[0];
      console.log(`\n🧪 Testing message sending to @${firstUser.username} (Chat ID: ${firstUser.chat_id})...`);
      
      const testMessage = `🧪 Test message from Big Drops Marketing Bot

This is a test message to verify that the bot can send messages successfully.

Time: ${new Date().toLocaleString()}
User: @${firstUser.username}`;
      
      const result = await sendMessage(firstUser.chat_id, testMessage);
      
      if (result.ok) {
        console.log('✅ Test message sent successfully!');
        console.log('📋 Message ID:', result.result.message_id);
        console.log('📅 Date:', new Date(result.result.date * 1000).toLocaleString());
      } else {
        console.log('❌ Failed to send test message:', result.description);
        console.log('🔍 Error code:', result.error_code);
        
        if (result.error_code === 403) {
          console.log('💡 This usually means the user has blocked the bot or deleted the chat');
        } else if (result.error_code === 400) {
          console.log('💡 This might be an invalid chat ID or bot permissions issue');
        }
      }
    }
    
    await pool.end();
    
  } catch (error) {
    console.log('❌ Error:', error.message);
  }
}

checkUsersAndTestMessage();

================================================================================
webhook-debug.js
================================================================================
const https = require('https');
const http = require('http');

const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const WEBHOOK_URL = process.env.WEBHOOK_URL || 'https://publisher-form-nu.vercel.app/api/telegram-webhook';

if (!BOT_TOKEN) {
  process.exit(1);
}

async function getWebhookInfo() {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/getWebhookInfo`,
      method: 'GET'
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.end();
  });
}

async function testWebhookEndpoint() {
  return new Promise((resolve, reject) => {
    const testUpdate = {
      update_id: 999999999,
      message: {
        message_id: 1,
        from: {
          id: 123456789,
          is_bot: false,
          first_name: "Test",
          username: "testuser",
          language_code: "en"
        },
        chat: {
          id: 123456789,
          first_name: "Test",
          username: "testuser",
          type: "private"
        },
        date: Math.floor(Date.now() / 1000),
        text: "/start"
      }
    };

    const url = new URL(WEBHOOK_URL);
    const options = {
      hostname: url.hostname,
      port: url.port || (url.protocol === 'https:' ? 443 : 80),
      path: url.pathname,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'TelegramBot/1.0',
        'Content-Length': JSON.stringify(testUpdate).length
      }
    };

    const protocol = url.protocol === 'https:' ? https : http;
    
    const req = protocol.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve({
            statusCode: res.statusCode,
            headers: res.headers,
            body: result
          });
        } catch (error) {
          resolve({
            statusCode: res.statusCode,
            headers: res.headers,
            body: responseData
          });
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.write(JSON.stringify(testUpdate));
    req.end();
  });
}

async function testBotToken() {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/getMe`,
      method: 'GET'
    };

    const req = https.request(request, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.end();
  });
}

async function debugWebhook() {
  try {
    const botInfo = await testBotToken();
    if (botInfo.ok) {
    } else {
      return;
    }
    
    const webhookInfo = await getWebhookInfo();
    
    if (webhookInfo.ok) {
      const info = webhookInfo.result;
      if (!info.url) {
        return;
      }
      
      if (info.last_error_message) {
        return;
      }
      
      if (info.pending_update_count > 0) {
      }
      
    } else {
      return;
    }
    
    try {
      const endpointResult = await testWebhookEndpoint();
      if (endpointResult.statusCode === 200) {
      } else {
      }
      
    } catch (endpointError) {
    }
    
  } catch (error) {
  }
}

debugWebhook();

================================================================================
setup-telegram-webhook.js
================================================================================
const https = require('https');

const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;

if (!BOT_TOKEN) {
  console.error('❌ TELEGRAM_BOT_TOKEN environment variable is not set!');
  console.error('Please set it in your environment or .env.local file');
  process.exit(1);
}

function setWebhook(webhookUrl) {
  return new Promise((resolve, reject) => {
    const data = JSON.stringify({ url: webhookUrl });
    
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/setWebhook`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
      }
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.write(data);
    req.end();
  });
}

function getWebhookInfo() {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/getWebhookInfo`,
      method: 'GET'
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.end();
  });
}

function deleteWebhook() {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/deleteWebhook`,
      method: 'POST'
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve(result);
        } catch ( catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.end();
  });
}

async function main() {
  try {
    const webhookInfo = await getWebhookInfo();
    
    const webhookUrl = process.argv[2];
    
    if (!webhookUrl) {
      return;
    }
    
    if (webhookUrl === 'delete') {
      const result = await deleteWebhook();
      return;
    }
    
    const result = await setWebhook(webhookUrl);
    
    const verifyInfo = await getWebhookInfo();
    
  } catch (error) {
  }
}

main();

================================================================================
monitor-webhook.js
================================================================================
const https = require('https');

const BOT_TOKEN = '8270513237:AAFDQKccnayiW8CiWyHLtBXjriZ8e7k4QBQ';

async function getUpdates() {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'api.telegram.org',
      port: 443,
      path: `/bot${BOT_TOKEN}/getUpdates?limit=10&timeout=30`,
      method: 'GET'
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const result = JSON.parse(responseData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.end();
  });
}

async function monitorWebhook() {
  try {
    const updates = await getUpdates();
    
    if (updates.ok) {
      if (updates.result.length === 0) {
      } else {
        updates.result.forEach((update, index) => {
          if (update.message) {
            const msg = update.message;
            
            
            
          }
          
          if (update.callback_query) {
          }
          
        });
      }
    } else {
    }
    
  } catch (error) {
    console.error('❌ Error monitoring webhook:', error);
  }
}

monitorWebhook(); 

================================================================================
cleanup-test-data.js
================================================================================
const { Pool } = require('pg');

const pool = new Pool({
  connectionString: 'postgresql://neondb_owner:npg_R5eKDZ4gdAsk@ep-winter-wind-aehcpswx-pooler.c-2.us-east-2.aws.neon.tech/neondb?channel_binding=require&sslmode=require',
  ssl: {
    rejectUnauthorized: false
  }
});

async function cleanupTestData() {
  try {
    const currentUsers = await pool.query('SELECT * FROM telegram_users ORDER BY created_at DESC');
    currentUsers.rows.forEach((user, index) => {
      console.log(`${index + 1}. @${user.username} (ID: ${user.chat_id}) - ${user.first_name}`);
    });
    
    const deleteResult = await pool.query(
      'DELETE FROM telegram_users WHERE chat_id = $1 RETURNING username, chat_id',
      ['123456789']
    );
    
    if (deleteResult.rows.length > 0) {
      deleteResult.rows.forEach(user => {
        console.log(`   - @${user.username} (${user.chat_id})`);
      });
    } else {
      console.log('ℹ️  No test entries found to delete');
    }
    
    const finalUsers = await pool.query('SELECT * FROM telegram_users ORDER BY created_at DESC');
    if (finalUsers.rows.length > 0) {
      finalUsers.rows.forEach((user, index) => {
        console.log(`${index + 1}. @${user.username} (ID: ${user.chat_id}) - ${user.first_name}`);
      });
    } else {
      console.log('   No users in database');
    }
    
  } catch (error) {
  } finally {
    await pool.end();
  }
}

cleanupTestData(); 

================================================================================
END OF CODEBASE
================================================================================

This file contains all the TypeScript (.ts) and JavaScript (.js) files from your Creative System Publisher Form project, excluding node_modules and Next.js related files.

The codebase includes:
- Configuration files (next.config.ts, next-env.d.ts)
- Database and core libraries (db.ts, utils.ts, emailService.ts, ocrHelpers.ts, uploadHelpers.ts)
- Services and API layer (api.ts)
- Types and constants (creative.ts)
- Utilities and hooks (validation.ts, fileUtils.ts, useCreativeForm.ts)
- API routes for offers, Claude AI, database checks, proofreading, file uploads, submissions, and Telegram integration
- JavaScript utility files for database management, Telegram bot testing, email configuration, and webhook management
- Main page component

Note: The useCreativeForm.ts hook file is very large (1234 lines) and contains the main form logic, so it's referenced but not fully included in this documentation.
